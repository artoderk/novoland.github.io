<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>MySQL总结</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">非递归的二叉树遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C总结 + 虚拟内存</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache 与 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">MySQL总结</h1>
  <div style="line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;">
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">一. 事务隔离级别</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://en.wikipedia.org/wiki/Isolation_%28database_systems%29" style="background: transparent;" target="_blank">WIKI</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">规定事务间的可见性。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. read uncommited</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最弱，事务的所有动作对其他事务都是立即可见的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">问题： <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">脏读</code> </strong><br/>即看到其他事务中间状态的数据。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. read commited</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只能读到其他事务已提交的数据，中间状态的数据则看不到，解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">脏读</code>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常这是通过读写锁实现的，写锁直到事务提交时才释放，在此期间其他事务无法读取该数据。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">问题：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">non-repeatable read</code></strong><br/>同一事务内，对同一条记录，两次读取间如果有其他事务对其的更新提交了，则看到的数据不同。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. repeatable read</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">non-repeatable read</code>的问题，保证在一个事务内，对同一条记录的重复读都是一致的。<em>是InnoDB的默认隔离级别。</em></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常，数据库是通过引入 <strong style="font-weight: bold;">多版本并发控制</strong>（即后面提到的<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">MVCC</code>）机制实现<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">repeatable read</code>的。数据在事务开始时就建立一个snapshot，此后的读看到的始终是这个snapshot；<strong style="font-weight: bold;">此外，对snapshot的读也不需要读锁，提高了并发</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">问题：<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code></strong><br/>对于某个范围的查询，两次查询间如果有其他事务在该范围内进行了删除或新增，则第二次查询会发现多/少了某些记录。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">对<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code>的解决方案：</strong><br/>引入<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">range lock</code>区间锁，读/写时，除了对满足条件的记录加锁，记录之间的区间也加锁，保证不会出现区间内的插入操作。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. serial</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">最高，所有事务都是串行的。</p>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">二. 并发</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. 锁优化1：拆分，读写锁</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">读锁 -- 共享锁 -- shared<br/>写锁 -- 排他锁 -- exclusive</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. 锁优化2：降低粒度</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><em>表锁由 mysql服务器 实现，行锁由 存储引擎 实现。</em></p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">表锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">显式的表锁：<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">lock table xxx read/write;</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM几乎完全依赖MySQL服务器提供的表锁机制。</p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">使用MyISAM时对锁的优化：</h4>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">缩短锁定时间：拆分query / 索引</li>
<li style="line-height: 1.6;">打开concurrent insert(在尾部并发insert)</li>
<li style="line-height: 1.6;">根据需要设置读写的优先级。默认写大于读</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">行锁</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB实现了行锁，基于索引的 index-row locking，<strong style="font-weight: bold;">如果锁了次级索引中的记录，则对应主索引中的记录也会被锁住</strong>。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">update/delete/insert会加x锁</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">查询时也可以设置显式加锁：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">select... for update</code>: x lock</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">two-phase locking protocol</code>：事务内部获得的锁在提交时一起释放</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. MVCC</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">InnoDB实现了MVCC。简单的说，MVCC为某条记录创建多个snapshot，不同事务读取各自的snapshot，互不影响。MVCC的引入有两个作用：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">实现 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">repeatable read</code> 事务隔离级别，同时解决<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code>问题；</li>
<li style="line-height: 1.6;">使普通的select避免加锁，提高并发。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只工作在RC &amp; RR两个隔离级别下。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">MySQL的两种read方式</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">snapshot read(non-lock) / consistent read</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">current read(lock) / lock read</code>:</li>
</ol>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">a. "snapshot read"</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">普通的select就是snapshot read，读快照，不会锁, 但是不同的隔离级别中的行为是不一样的:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">RC: 最近的snapshot  -- read commited，看到其他事务的动作</li>
<li style="line-height: 1.6;">RR: 事务开始时的snapshot  -- <strong style="font-weight: bold;">repeatable  read</strong>，一致性</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">snapshot read</code> 在RC和RR中的工作方式都满足其隔离级别的定义。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-consistent-read.html" style="background: transparent;" target="_blank">Consistent Nonlocking read</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">If the transaction isolation level is REPEATABLE READ (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction. </p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">You can get a fresher snapshot for your queries by committing the current transaction and after that issuing new queries.</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.</p>
</blockquote><h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">b. "current read / lock read"</h4>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">select... lock in shared mode</code>: s lock</li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">select... for update</code>: x lock</li>
<li style="line-height: 1.6;">DML（insert/delete/update）也属于 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">lock read</code></li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-locking-reads.html" style="background: transparent;" target="_blank">SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE Locking Reads</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">lock read下操作的是数据的最新版本，该模式最主要的作用是 <strong style="font-weight: bold;">在RR隔离级别上</strong> 解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code>的问题，这是通过<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">gap lock</code>实现的。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">4. gap lock &amp; phantom read</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">在<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">repeatable read</code>级别上, <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">lock read</code> 时使用了 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">gap-key lock</code> 解决 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phathom read</code> 问题: 不仅锁找到的记录，还锁区间，保证区间内的值无法被插入。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意，无法使用索引时会走主索引实现全表扫描，此时会给所有的记录加上record lock，并对其所有的区间加gap lock，表完全锁死，此时只能进行 snapshot read，极大地降低并发，这就是为何update/delete尽量要走索引的原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">注意：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">普通的 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">snapshot read</code> 依然有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code>，只能保证<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">可重复读</code>；只有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">lock read</code> 既解决了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">phantom read</code>，又保证了<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">可重复读</code>。</li>
<li style="line-height: 1.6;">RC级别没有<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">gap lock</code>，只有 <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">record lock</code>。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://hedengcheng.com/?p=771" style="background: transparent;" target="_blank">何登成的《MySQL 加锁处理分析》</a><br/><a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html" style="background: transparent;" target="_blank">innodb-record-level-locks`</a></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 查询锁的争用情况</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">表锁<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">show status like 'table%'</code><br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">Table_locks_immediate</code>:立即获得表锁的次数<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">Table_locks_waited</code>:需要等待获得表锁的次数</li>
<li style="line-height: 1.6;">innodb的行锁<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">show status like 'innodb_row_lock'</code><br/>current_waits:<br/>waits:<br/>time:<br/>time_avg:<br/>time_max:</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">三. 优化query (粗略)</h1>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">定位瓶颈</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">IO or CPU?</p>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">工具</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">explain &amp; profile</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">基本原则</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">join时小结果集驱动大结果集</li>
<li style="line-height: 1.6;">利用索引完成排序/分组</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只取需要的列（？）<br/> a. network<br/> b. 不能使用Covering index<br/> c. 优化排序</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">仅仅使用最有效的过滤条件<br/> 建立索引的字段越小越好，减少IO</p>
</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">避免复杂join和子查询<br/> 对于MyISAM，join会锁住所有相关的表（s lock），可能阻塞DML其他很长时间，此时可以在程序中做join，降低对锁的占用，减少阻塞；<br/> 对应用而言，SQL的执行时间：网络/执行（CPU+IO）/锁阻塞，优化瓶颈<br/> 子查询实现不好，不一定会走索引</p>
</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">Explain</h1>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">四. 索引</h1>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><a href="http://www.percona.com/files/presentations/percona-live/london-2011/PLUK2011-practical-mysql-indexing-guidelines.pdf" style="background: transparent;" target="_blank">Practical MySQL indexing guidelines</a></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MyISAM 和 InnoDB 的索引，采用的数据结构都是B+树。</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">1. B树和B+树</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B树的结构类似二叉查找树，只不过节点的度远远大于2，查找的复杂度为树的高度，O(logdN)：<br/><img alt="Alt text" class="en-media" longdesc="./1402812459074.png" name="6110437c-cb5b-4148-9a0d-9cbea5a7d5fd" src="/assets/img/81bb92fa7c27d9aef499efc82c4aaa73.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">通常会将根据硬盘上一个page的大小来调整节点的度，原因是在基于外存的查找数据结构中，性能的瓶颈在于IO，这样的处理一可以让一个节点一次IO即可读入，二可以显著降低树的高度，查找时只需几次page的IO即可定位到目标。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">B+树</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">B+树是对B树的优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">只有叶子节点存data，内节点只存key；<br/> 好处：提高内节点的度，降低高度</li>
<li style="line-height: 1.6;">叶子节点加上了next指针，形成一个链表<br/> 好处：快速范围查找，只需确定起点和终点，顺序扫描即可。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813534888.png" name="f3392b7b-c733-4b80-ba43-d51f8cc1cf8c" src="/assets/img/9467b1f6665fb48464f4699db1a4bec2.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">2. MyISAM的索引</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">索引和数据分离，数据文件：堆表(按插入有序)</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">主键索引和非主键索引结构一致，叶子节点存储的是行的物理位置信息（row number）</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><img alt="Alt text" class="en-media" longdesc="./1402813593672.png" name="a8cab548-fa57-4191-90c6-5ff93e80c322" src="/assets/img/10b0700762cf9c5bfd97396ccfb7c8b3.png" style="border: 0; max-width: 100%; border-radius: 8px;"/></p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">3. InnoDB的索引</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">primary index（主键索引）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">数据文件就是主键索引文件，叶子节点存真实数据，这种方式称为 聚集索引。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果没有主键，InnoDB会试着使用一个Unique Nonnullable index代替；如果没有这种索引，会定义隐藏的主键。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">secondary index</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">非主键上的索引称为次级索引，叶子节点存主键，此时需要查找两次。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">优缺点</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优点： 将相关数据保存在一起，减少IO；MyISAM访问每个行都得访问数据文件</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">缺点：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">B+树的节点按page聚集，存储着数据，因此主索引叶子节点分裂的机会远远大于非聚集索引；split会导致 <ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">移动大量数据; </li>
<li style="line-height: 1.6;">需要更多空间（碎片）; </li>
<li style="line-height: 1.6;">split时会给整个索引加x锁，不可访问</li>
</ul>
</li>
<li style="line-height: 1.6;">按主键顺序插入最快；乱序插入慢(频繁分裂)，因此 <strong style="font-weight: bold;">更适合用自增主键</strong></li>
<li style="line-height: 1.6;">secondary index包含了主键，体积可能很大，因此 <strong style="font-weight: bold;">不适合用过长字段当主键</strong></li>
<li style="line-height: 1.6;">在secondary index上可能需要查找两次，一次查自己，一次查主索引。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">4. 什么样的查询条件会走索引?</h2>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">区分<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">范围查询</code>和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">等值查询</code></p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">in</code>是多个等值查询，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">between</code>二者都有可能。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">范围查询 使用索引的方式，是先确定起点，再根据叶子节点组成的链表顺序扫描，直到终点。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">等值查询 则是从上到下搜索树。</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">假如有索引<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">&lt;a,b,c,d&gt;</code>：</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 最左前缀的等值查suoyin询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一旦出现空洞，后面的列就不能使用索引了，但空洞可以用<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">in所有值</code>填充</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 范围查询</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">只有第一个范围查询及前面的列可以使用索引，后面的即使构成最左前缀也不会走索引。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">因此，较常进行范围查询的列要放在索引的后面。</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 字符串<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">%</code>如果放在开头则无法走索引</h3>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">5. 建立索引时的优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 不适合创建索引的情况</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">唯一性太差的列<br/> 引擎根据统计信息会做优化，可能建了也不走</li>
<li style="line-height: 1.6;">频繁更新的列<br/> 需要同时维护索引和数据    </li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 前缀索引 和 selectivity（选择性）</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：列太长，太消耗空间；解决方案：用前缀建立索引<br/>但是又要保证良好的selectivity<br/>selectivity = (distinct values) / all records</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 尽量使用多列复合索引而不是多个单列索引</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">减少维护索引的开销<br/>多个单列索引老版本只会选一个，5.0以后可以用index merge，扫描多个再合并结果（or/and）</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 选择正确的列顺序</h3>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">一般来说选择性高的放前面，在最初阶段就可以排除大部分记录，减少后续需要考察的数据量；</li>
<li style="line-height: 1.6;">最常用的放在前面，范围查询的字段尽量靠后。</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">6. 查询优化</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">a) 查询条件中不要对列做运算，否则无法使用索引；</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">b) 使用覆盖索引</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">Covering index: 覆盖了查询的所有列，避免访问数据文件/聚集索引<br/>发起的查询被索引覆盖时，会在Extra出现Using Index</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">c) 优化join</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL只支持nested loop join，没有hash join或者sort merge join。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">nested loop join</code><br/>两层循环</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">hash join</code><br/>驱动表先构造hash table，扫描另一张表，并查找hash table看是否有对应记录</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">sort merge join</code><br/>两张表先排序，然后交替扫描进行join。这个过程类似归并排序的归并阶段</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当join无法使用索引（type是all/index/range/index_merge，用到是ref）时会用到join buffer，缓存中间的结果集</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">某些情况下拆分join效率更高：<ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">在应用端可以利用缓存</li>
<li style="line-height: 1.6;">减少MyISAM的表锁时间</li>
<li style="line-height: 1.6;">对大表用in替换join，更高效</li>
</ul>
</li>
<li style="line-height: 1.6;">减小最外层循环次数，即用小结果集驱动join（优化器会帮你挑选较小的表做驱动表）</li>
<li style="line-height: 1.6;">保证被驱动表上的join字段被索引</li>
<li style="line-height: 1.6;">只group by或order by驱动表上的列，这样可以在join前排序</li>
<li style="line-height: 1.6;">被驱动表无法走索引时，保证join buffer足够大</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">d) 优化 order by</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">当不能用索引实现排序时，mysql必须对存储引擎返回的记录排序，这个过程被称为filesort（但不一定发生在磁盘上）。纯内存时快速排序，外存时分块快速排序再归并。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">两种filesort算法：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">order by 字段和行指针取出，在sort buffer中排序；然后通过行指针取出需要的列。需要访问两次数据，但内存消耗少。</li>
<li style="line-height: 1.6;">一次性将所有需要的列取出，在sort buffer中排序，需要更多内存。</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">参数：max_length_for_sort_data，结果集长度超过该参数时用第一种。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">对join的排序:</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">如果只用了驱动表的字段排序：先排序，再join</li>
<li style="line-height: 1.6;">否则先join，结果集放temp table，然后再排序（Using temporary; Using filesort）</li>
</ol>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><strong style="font-weight: bold;">尽量走索引</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">order by时必须要能使用索引的最左前缀(order by+where条件中的常量组成最左前缀也可以)，且order by的方向都相同</li>
<li style="line-height: 1.6;">join时，order by的列必须引用第一个表（驱动表）</li>
</ul>
</li>
<li style="line-height: 1.6;"><strong style="font-weight: bold;">优化filesort</strong><ul style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">内存多时加大max_length_for_sort_data，返回记录小于时用新算法，大于用老算法；</li>
<li style="line-height: 1.6;">用第二种算法时，去掉不必要的返回字段（会用更多内存）</li>
<li style="line-height: 1.6;">加大sort_buffer_size，减小排序过程的IO</li>
</ul>
</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">e) 优化 group by / distinct</h3>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">group by：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">比order by多了分组和聚合函数计算的步骤，因此优化方式和order by基本类似。</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> 1. 走索引，可以避免额外排序</strong></p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 0; margin-bottom: 5px; font-size: 18px;">索引访问方式</h4>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">1. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">loose index scan</code>（MySQL不支持）</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">当前对 <strong style="font-weight: bold;">范围查询</strong> 的处理方式(range scan)是<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">走叶子节点链表扫描</code>，当后续有其他列上的过滤条件时，不支持在 <strong style="font-weight: bold;">从上往下搜索的时候，对一个范围内的所有子树，利用后续列的其他条件进行查找并合并结果集</strong> 的工作方式。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">举个例子，idx(a,b,c)，where a = 1 and b &lt; 3 and c = 1，不用loose index scan时的range scan方式：</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">找到b=3的最右侧叶子节点，往前扫描，再用c=1在链表上过滤，这种方式在搜索的时候实际上只用到了ab两列;</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">但是显然有一种更好的方式，即在树上从上往下搜索到b&lt;3的所有区间后，对每个子树用c=1的条件过滤，并合并结果。这就是所谓的loose index scan。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">这就是 idx(a,b,c)少了只有a/c当查询条件是只能用到a列；ab都有范围查询只能用到a列 的根本原因。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Mysql的B+索引只支持等值查询，in实际上是和其他条件进行笛卡尔积后的多个等值查询，因此在查询b/c列时，如果用a in ('男','女')补上这个空洞时，又是可以走索引的。</p>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;">可以使用下面两种方式加速分组</strong>：</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">2. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">伪loose index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">group by在有些情况下可以使用这种方式加速查询。<br/>idx(a,b,c)，<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">select max(c) where ... group by a,b</code>时对每个a+b的唯一组合的区间，找到该子树的最左（右）节点，然后合并结果即可。<br/>这种工作方式和真正的loose scan类似，都是合并子树的搜索结果，但仅需要访问子树的部分节点。它的局限在于仅适用某些聚合函数如min/max，且查询字段必须在group by字段后面，二者一起组成最左前缀。</p>
<h5 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 14px;">3. <code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">Tight index scan</code>:</h5>
<p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">和<code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #fff; white-space: nowrap; border-radius: 3px; margin: 0 4px;">伪loose index scan</code>类似，但需要访问整个子树，对其所有节点做分组/聚合，不能直接拿到结果。</p>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;"><a href="http://docs.oracle.com/cd/E16655_01/server.121/e15858/tgsql_optop.htm#TGSQL95163" style="background: transparent;" target="_blank">B+树索引访问方式</a></p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> 2. 不能用索引时，mysql必须先将数据放入临时表，然后filesort。</strong></p>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 25px; margin-bottom: 15px; font-size: 18px;">distinct：</h4>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">与group by的实现方式是一样的，因此优化方式也类似：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">伪loose index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">tight index scan</code></li>
<li style="line-height: 1.6;"><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">filesort</code>，但distinct不需要排序</li>
</ol>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">f) count</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">count(<em>): 统计结果集的行<br/>count(列/表达式): 统计值的个数，排除null<br/>MyISAM维护了表的总行数，所有没有where条件的count(</em>)很快<br/>工作方式：扫描符合条件的记录，统计<br/>一个sql语句统计不同值的count：<br/><code style="font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 4px; margin: 0 4px;">SELECT COUNT(color = 'blue' OR NULL) AS blue, COUNT(color = 'red' OR NULL) AS red FROM items</code><br/>很难优化，覆盖索引？</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">g) limit &amp; offset</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">一般瓶颈在于扫描的数据太多，limit 10000,20会扫描10020行数据，再丢弃前10000行.</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">优化：利用covering index在索引上偏移，而不是全表上偏移 --  可以先在索引上偏移再join原表获取其他列。<br/>(没别的办法了？？)</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">h) union</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">MySQL总是用temp table实现union<br/>使用union all而不是union，后者会对temp table做distinct操作，开销很大</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;"><strong style="font-weight: bold;"> 附：数据访问方式，出现在explain的type列里 </strong> </p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">(all)        Full table scan          全表扫描</li>
<li style="line-height: 1.6;">(index)      Index scan               索引全部扫描：找到最左叶子节点，然后走链表</li>
<li style="line-height: 1.6;">(range)      Range Scan               索引范围扫描：找到范围的最左（右）侧叶子，然后走链表<br/>例外：in显示的是range，但是是索引唯一扫描，等同于多个相等条件</li>
<li style="line-height: 1.6;">(ref/eq_ref) Unique Index Lookup      索引唯一扫描，走树</li>
<li style="line-height: 1.6;">(const)      Constant</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; line-height: 1.6; margin-top: 20px; margin-bottom: 20px; border: 0; border-top: 1px solid rgba(102, 128, 153, 0.15);"/>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">五. 可扩展设计</h1>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">分布式事务</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">合理设计切分规则，保证事务所需数据在同一个DB上，避免分布式事务</li>
<li style="line-height: 1.6;">拆分成小事务，app保证整体事务完整性</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">最终一致性</h2>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">为了HA/负载均衡需要冗余数据，数据冗余的地方就存在一致性的问题</p>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">同一个数据只要保存在多个地方，且至少有一个地方被写，就存在一致性问题<br/>如果保存在多个地方被写，情况就更复杂了，涉及到数据的传播/并发/事务，尽量避免这个情况，保证数据在一个地方被增删改。</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">shard还是一个数据在一个地方</p>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">如果session是各个容器自己管理的，因为要是强一致性的，必然需要session的复制<br/>如果每个容器有自己的本地cache，且会update/remove，和cpu的L1/L2/L3缓存的情形类似，都要实现cache的传播</p>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">Replication</h2>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">Master-Slaves 读写分离，负载均衡</li>
<li style="line-height: 1.6;">Dual Master 双机热备HA</li>
</ol>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 30px;">数据切分(shard)</h2>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">垂直</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">按业务模块切分<br/>需要程序进行不同库之间的join</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">水平</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">每个库的表结构是一样的，按id划分数据<br/>数据局部性好，很多表关联/事务能够在一个DB完成</p>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">结合：先垂直再水平</h3>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px; font-size: 24px;">切分后的整合</h3>
<p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">统一数据访问层 -- 路由规则/解析sql/合并结果/join/分布式事务/负载均衡都可以在这一层搞定<br/>一些开源产品：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 15px 0; font-size: 14px; border-left: 5px solid #ddd; background-color: rgba(102, 128, 153, 0.05);">
<ol style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">MySQL Proxy</li>
<li style="line-height: 1.6;"><p style="margin: 0 0 10px; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Amoeba (JDBC以下)<br/> query路由/过滤，负载均衡，读写分离，HA<br/> 主要解决：</p>
<ol style="margin-top: 0; margin-bottom: 0; line-height: 1.6;">
<li style="line-height: 1.6;">数据切分后复杂数据源整合;</li>
<li style="line-height: 1.6;">提供数据切分规则并降低数据切分规则给数据库带来的影响;</li>
<li style="line-height: 1.6;">降低数据库与客户端的连接数;</li>
<li style="line-height: 1.6;">读写分离路由</li>
</ol>
<p style="margin: 0 0 10px; margin-bottom: 0; line-height: 1.6; font-size: 14px; font-weight: 300; white-space: pre-wrap; word-wrap: break-word;">Amoeba for MySQL/Aladin</p>
</li>
<li style="line-height: 1.6;">hibernate shards / ibatis shards</li>
</ol>
</blockquote><p style="margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;">问题：</p>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">分布式事务</li>
<li style="line-height: 1.6;">跨节点join</li>
<li style="line-height: 1.6;">跨节点合并排序分页<br/>都由应用解决吧</li>
</ol>
<h1 style="font-size: 36px; margin: 0.67em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 30px; margin-bottom: 20px;">参考书籍：</h1>
<ol style="margin-top: 0; margin-bottom: 10px; line-height: 1.6;">
<li style="line-height: 1.6;">《高性能MySQL》</li>
<li style="line-height: 1.6;">张宴的《MySQL调优与架构设计》</li>
</ol>
</div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html&text=MySQL总结" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html&title=MySQL总结" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
