<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>克鲁斯卡尔的博客</title>
    <link>http://novoland.github.io</link>
    <atom:link href="http://novoland.github.io/rss.xml" rel="self" type="application/rss+xml" />
    <description>一个程序员</description>
    <language>zh-CN</language>
    <pubDate>Tue, 05 May 2015 09:52:41 +0800</pubDate>
    <lastBuildDate>Tue, 05 May 2015 09:52:41 +0800</lastBuildDate>

    
    <item>
      <title>GIT常用操作</title>
      <link>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</link>
      <pubDate>05 May 2015</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT常用操作</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;GIT常用操作&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;本地&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;初始化和设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;工作流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;查看文件状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;忽略文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;工作区&amp;lt;==&amp;gt;暂存区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;暂存区==&amp;gt;版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;本地版本库&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;branch 和 HEAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;分支的增删查改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;分支合并&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. merge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. rebase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. 冲突解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. 优缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;相对路径^和~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;撤销提交&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. reset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. revert&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;随意移动commit&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. cherry-pick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. rebase -i&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;远程&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;clone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;fetch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;pull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;push&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;常见GIT工作流&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;集中式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Forking 工作流&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Tips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr style=&quot;-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;&quot;/&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;本地&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;初始化和设置&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git init &lt;span style=&quot;color: #75715e;&quot;&gt;# 创建新仓库&lt;/span&gt;

$ git config --global user.email &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;c@d.com&quot;&lt;/span&gt; &lt;span style=&quot;color: #75715e;&quot;&gt;# 设置全局email&lt;/span&gt;
$ git config --global user.name &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;Anderson&quot;&lt;/span&gt; &lt;span style=&quot;color: #75715e;&quot;&gt;# 设置全局用户名&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;要为某个repo设置单独的email和用户名，把上述命令中的 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;--global&lt;/code&gt;去掉。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;.git&lt;/code&gt;文件夹保存本地仓库git相关的所有信息，如果要恢复成一个普通文件夹，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rm -rf .git&lt;/code&gt;删除之即可。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;工作流&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;本地仓库由3个区域组成，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;工作区&lt;/code&gt;持有你的源码等实际文件，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;像个工作区和版本库之间的buffer，临时存储你的改动，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;本地版本库&lt;/code&gt;记录着你每一次的提交，并维护若干分支。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428911979022.png&quot; name=&quot;84783623-df91-4ee3-bf30-3fe6ebc701de&quot; src=&quot;/assets/img/8140cecb95c65f2c709de3c504598f45.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;查看文件状态&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;所有文件都处在两个状态之一：&lt;strong style=&quot;font-weight: bold;&quot;&gt;untracked&lt;/strong&gt; 和 &lt;strong style=&quot;font-weight: bold;&quot;&gt;tracked&lt;/strong&gt;。&lt;strong style=&quot;font-weight: bold;&quot;&gt;untracked&lt;/strong&gt; 的文件未被纳入git的版本控制，&lt;strong style=&quot;font-weight: bold;&quot;&gt;tracked&lt;/strong&gt;状态又可被细分为以下三个状态：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;unmodified&lt;/strong&gt;：与版本库中的最新文件一致&lt;/li&gt;
&lt;li&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;modified&lt;/strong&gt;：顾名思义&lt;/li&gt;
&lt;li&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;staged&lt;/strong&gt;：修改过，并已加入&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;，坐等提交&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428915917524.png&quot; name=&quot;19ed4a42-72fa-429b-9a4e-c8f03bcd91a1&quot; src=&quot;/assets/img/770f99d22becaf3e57b3c253789581b2.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;查看文件状态：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git status&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;忽略文件&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;根目录下的&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;.gitignore&lt;/code&gt;文件描述了哪些文件需要被git忽略：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;# 此为注释 – 将被 Git 忽略&lt;/span&gt;
*.a &lt;span style=&quot;color: #75715e;&quot;&gt;# 忽略所有 .a 结尾的文件&lt;/span&gt;
!lib.a &lt;span style=&quot;color: #75715e;&quot;&gt;# 但 lib.a 除外&lt;/span&gt;
/TODO &lt;span style=&quot;color: #75715e;&quot;&gt;# 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO &lt;/span&gt;
build/ &lt;span style=&quot;color: #75715e;&quot;&gt;# 忽略 build/ 目录下的所有文件&lt;/span&gt;
doc/*.txt &lt;span style=&quot;color: #75715e;&quot;&gt;# 会忽略 doc/notes.txt 但不包括 doc/server/arch.tx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;工作区&amp;lt;==&amp;gt;暂存区&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;将&lt;strong style=&quot;font-weight: bold;&quot;&gt;untracked&lt;/strong&gt;或&lt;strong style=&quot;font-weight: bold;&quot;&gt;modified&lt;/strong&gt;文件加入&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;（这个过程称为 stage）：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果改了&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;内的文件，需要再次&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;$ git add&lt;/code&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;$ git add .&lt;/code&gt; ：&lt;em&gt;偷懒，慎用&lt;/em&gt;。递归把当前目录下所有&lt;strong style=&quot;font-weight: bold;&quot;&gt;untracked&lt;/strong&gt;或&lt;strong style=&quot;font-weight: bold;&quot;&gt;modified&lt;/strong&gt;文件加入&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;unstage某个文件（文件内容不会变）：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;撤销对某个文件的修改，文件恢复到&lt;strong style=&quot;font-weight: bold;&quot;&gt;unmodified&lt;/strong&gt;状态，与版本库一致：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout &amp;lt;file&amp;gt;
$ git checkout .&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;删除、移动、重命名文件：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git rm &amp;lt;file&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#工作区的文件被删除，删除操作会被记录到暂存区&lt;/span&gt;
$ git mv &amp;lt;file_from&amp;gt; &amp;lt;file_to&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#移动、重命名&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;暂存区==&amp;gt;版本库&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;从&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;提交到&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;本地版本库&lt;/code&gt;：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git commit -m &lt;span style=&quot;color: #e6db74;&quot;&gt;&#39;description&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;stage动作和commit动作二合一，自动将&lt;strong style=&quot;font-weight: bold;&quot;&gt;tracked&lt;/strong&gt;文件的更新/删除提交到&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;(忽略&lt;strong style=&quot;font-weight: bold;&quot;&gt;untracked&lt;/strong&gt;文件)，然后commit，慎用：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git commit &lt;span&gt;-a&lt;/span&gt; -m &lt;span style=&quot;color: #e6db74;&quot;&gt;&#39;added new benchmarks&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;修改最后一次提交：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git commit --amend&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该命令有两个作用：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;提交当前&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;暂存区&lt;/code&gt;，并合并到上一次commit。常用于提交后发现漏了几个文件，又不想再提交一次的情况；&lt;/li&gt;
&lt;li&gt;可以修改上一次commit的描述。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;本地版本库&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;branch 和 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;简单地说，版本库是一个个commit连接起来的一张图，&lt;strong style=&quot;font-weight: bold;&quot;&gt;branch是指向某个commit的&lt;em&gt;指针&lt;/em&gt;&lt;/strong&gt;，从初始commit到该branch指向的commit的路径，形成了该分支的历史。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt; 是一个非常重要的概念，理解了&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;很多其他命令就很直观了。&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;本质上也是一个指针，它有两种状态：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;通常情况下，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;是一个branch的 &lt;strong style=&quot;font-weight: bold;&quot;&gt;引用/镜像&lt;/strong&gt;，此时&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;和该branch绑定(&lt;strong style=&quot;font-weight: bold;&quot;&gt;attach&lt;/strong&gt;)在一起，一起指向某个commit，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;和该branch指针的移动会互相同步（除了用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;checkout&lt;/code&gt;显式移动&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;）；&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;attach &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt; 到某一分支的命令：&lt;/p&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;也可以不attach到branch，而是指向某个commit，这种状态称为 &lt;em&gt;detached HEAD&lt;/em&gt;。注意，即使&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;与branch本质上指向同一commit，如果没有显式用1中命令attach &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;到分支则也是 detached HEAD 状态。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;同样地，用 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;checkout&lt;/code&gt; 命令将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;指向某个特定的 commit：&lt;/p&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout &amp;lt;commit id&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;所指向commit的版本，是当前工作区内文件的基准。除此之外，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;一个重要的作用是：&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt; 为很多git命令提供&lt;strong style=&quot;font-weight: bold;&quot;&gt;基准位置&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;比如：&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot; style=&quot;font-weight: bold; vertical-align: bottom; padding: .5em; line-height: 1.5; border-top: 0; border: 1px solid #ddd;&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;left&quot; style=&quot;font-weight: bold; vertical-align: bottom; padding: .5em; line-height: 1.5; border-top: 0; border: 1px solid #ddd;&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git commit&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;将新的commit链接在&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;后并更新&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;（链表的插入），如果&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到了某个branch，该branch也会被更新&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git branch &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;创建一个新的branch，值与&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;一致，与之指向同一个commit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git merge &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;将指定branch多出来的commit合并为一个并提交到&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;，后续逻辑与&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git commit&lt;/code&gt;一致&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;…&lt;/td&gt;
&lt;td align=&quot;left&quot; style=&quot;padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;&quot;&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;举例说明，假如初始状态如下图(master* 表示&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到了master分支)： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428930288886.png&quot; name=&quot;f2284a84-3ce1-4248-9f60-8ced1f2bd9ed&quot; src=&quot;/assets/img/6b6c720cd632b625bd57cec7df10beac.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;用以下命令将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;指向C0：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout C0&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428930234331.png&quot; name=&quot;10fd009b-4bb2-44bd-b0be-d0373259e337&quot; src=&quot;/assets/img/3d610609444fd854bfec6d0924b8a09e.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在该状态下做一次commit（C2），C2链接在&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;后并移动&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428931457954.png&quot; name=&quot;46ccb824-24eb-4757-8c5d-876d01038d0d&quot; src=&quot;/assets/img/f219100df20b41415e727f2964ac72f6.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果此时执行&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git checkout master&lt;/code&gt;将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到master，我们会丢失C2的引用，因此在C2处建一个 dev 分支（其实就算丢失了也没关系，神奇的&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;reflog&lt;/code&gt;命令可以找到C2的id）：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch dev &lt;span style=&quot;color: #75715e;&quot;&gt;# 以 HEAD 为基准建立 dev 分支&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;结果如下，dev与&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;同时指向C2： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428931720329.png&quot; name=&quot;f7319ad9-d665-4d00-9f76-2f5bece10075&quot; src=&quot;/assets/img/747d3e4f78e7b4a9ea01ca46d3a73f00.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;注意，这时依然是 detached HEAD 状态，再commit一次的话可以看到 dev 分支不受影响： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428931934972.png&quot; name=&quot;748bdaca-89f6-4fb9-b1c5-0ab1789c852d&quot; src=&quot;/assets/img/edfadbba4b8606277066aabc0e9dbf8c.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果要在dev分支上提交，必须先将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到dev：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout dev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428932457041.png&quot; name=&quot;3d9cc20b-9656-46d8-98ca-79b80c1382d8&quot; src=&quot;/assets/img/8c54cde6fd477a6b808b9a0ddecd1bb8.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;然后再commit： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428932491021.png&quot; name=&quot;18ecd23c-f793-434c-8e1e-359db004b314&quot; src=&quot;/assets/img/a256f5d9eb06637c41cb5509480ca9ea.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;现在将dev合并到master，根据之前描述的，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;merge&lt;/code&gt;的操作对象是&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;，因此先将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到master再做merge：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout master
$ git merge dev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428933640277.png&quot; name=&quot;8e2b7956-33c3-4b66-bd5c-a18f586ab451&quot; src=&quot;/assets/img/582c2d47b7e80e39bfc500d5524000a3.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果只是单纯地让&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;指向C1而不attach到master上，结果会是这样：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout C1&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428933812055.png&quot; name=&quot;768c0019-a8ca-4a72-9c96-f4e189b29653&quot; src=&quot;/assets/img/9e4515e312e3af0b48e328984954a427.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git merge dev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428933851514.png&quot; name=&quot;fb84380f-f3ae-41c9-8e25-e48ae3ac92fd&quot; src=&quot;/assets/img/9766006255eab425a1f9cf2697703a33.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;即操作的是&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;，master 分支不受影响。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;由上述例子可知，在针对某个分支操作之前，通常先要将&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;attach到该branch上，因此&lt;strong style=&quot;font-weight: bold;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;绑定的分支也被称为当前分支&lt;/strong&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;的位置可以通过 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;.git/HEAD&lt;/code&gt; 文件查看：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ cat .git/HEAD
e96c12854b77fe6f3dea81d593ddd2824eeaf9d6 &lt;span style=&quot;color: #75715e;&quot;&gt;#指向某个commit&lt;/span&gt;
$ git checkout develop
$ cat .git/HEAD
ref: refs/heads/develop &lt;span style=&quot;color: #75715e;&quot;&gt;#指向develop分支&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;分支的增删查改&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;分支的CRUD均由&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git branch&lt;/code&gt;命令完成。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;查询所有本地分支：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch
master
*develop    &lt;span style=&quot;color: #75715e;&quot;&gt;# 星号表示HEAD所在位置&lt;/span&gt;
bugfix&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;以&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;为基准，新建一个分支：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;删除一个分支：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch &lt;span&gt;-d&lt;/span&gt; &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;修改一个分支，“修改”实际上指的是&lt;strong style=&quot;font-weight: bold;&quot;&gt;移动branch指针&lt;/strong&gt;，理论上可以将一个branch指向任意commit：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch &lt;span&gt;-f&lt;/span&gt; &amp;lt;branch&amp;gt; &amp;lt;目标commit&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;重命名分支：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch -m &amp;lt;old_name&amp;gt; &amp;lt;new_name&amp;gt;
$ git branch -m &amp;lt;new_name&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#重命名当前分支&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;分支合并&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;假设有两个branch：bugfix和master，初始状态如下： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428935943072.png&quot; name=&quot;86f7de75-c7f2-45f0-8c1e-c9ea651764f3&quot; src=&quot;/assets/img/485928ca922508e5246b23d1b4595f99.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;现在要将 bugFix 合并到 master，我们有两种选择：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;1. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;merge&lt;/code&gt;&lt;/h5&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;git merge bugFix&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;merge&lt;/code&gt;的动作如下：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;将 bugFix 分支独有的commit（这里只有C2）合并为1个（C4），commit 到当前分支（&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;绑定的分支，即master）上；&lt;/li&gt;
&lt;li&gt;1中产生的新commit有两个parent，除了master的最末commit，bugFix指向的commit也是其parent。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;结果如下： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428936525569.png&quot; name=&quot;7c0ea7c1-5c7c-44b9-bf29-6b62c0e0f615&quot; src=&quot;/assets/img/18c6716eda9e5cc71f9a2d0fdeae0876.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;此时 bugFix 的 commit 被合并到了 master，master 含有了两个分支的提交信息（C3 + C4），但bugFix 却没有 master 分支的提交（即C3），如果想要让 bugFix 分支也含有全部提交，则可将master merge到bugFix：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout bugFix
$ git merge master&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;由于 bugFix 指向的 commit 实际上是 master 的祖先，因此这里的 merge 只会将 bugFix 分支 &lt;em&gt;fast-forward&lt;/em&gt; 到 master 分支，与其一同指向C4： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428937762260.png&quot; name=&quot;60a6b3cc-7450-4a4b-aeb2-73d11d582010&quot; src=&quot;/assets/img/ddc55bd463a9fd2f6ac4d59befe8bb66.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;2. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt;&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;对上面的场景我们也可以用 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt; 来进行分支合并：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;git rebase bugFix&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt;的工作流程可以想象成：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;将当前分支(master) &lt;em&gt;挪到&lt;/em&gt; 目标分支bugFix 处；&lt;/li&gt;
&lt;li&gt;将原master的独有 commit (C3)复制一份并依次提交到新 master。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;结果如下： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1428938627755.png&quot; name=&quot;9d025939-2e99-42c3-b8f5-c098263d93e4&quot; src=&quot;/assets/img/3da2732f1de2c9ec9dee804a1470e400.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;就像把 master 分支上的 commit “append” 到了 bugFix 分支。注意 C3 依然存在，C3’只是 C3 的一份拷贝。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;接下来也可以用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt;让bugFix与master保持同步，同样也是做一次 &lt;em&gt;fast-forward&lt;/em&gt;：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git checkout bugFix
$ git rebase master&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;3. 冲突解决&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git merge&lt;/code&gt; 时如果出现文件冲突，合并将失败，冲突的详细信息会写入对应文件中，此时应修改文件，手动解决冲突，并用 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 表明冲突已解决。最后 commit 即完可，该提交的 message 默认为 “Merge branch xxx into yyy”：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ edit &amp;lt;file1&amp;gt;
$ edit &amp;lt;file2&amp;gt;
$ git add &amp;lt;file1&amp;gt;
$ git add &amp;lt;file2&amp;gt;

$ git commit&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git rebase&lt;/code&gt; 实质上一个多个commit依次回放的过程，如果某次“回放”出现了冲突，可以修改文件手动解决冲突，并用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 表明冲突已解决。&lt;strong style=&quot;font-weight: bold;&quot;&gt;冲突修改完毕后不需要commit&lt;/strong&gt;，用下面命令继续 rebase：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git rebase --continue&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果中间遇到某个补丁不需要应用，可以用下面命令忽略：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;git rebase --skip&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果想回到rebase执行之前的状态，可以执行：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;git rebase --abort&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;4. 优缺点&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt;的优点是分支树会很干净，不会出现分叉，也不会有一个多余的&lt;em&gt;Merge From XXX&lt;/em&gt; 的commit；缺点是commit的顺序会错乱。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;相对路径&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;^&lt;/code&gt;和&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;~&lt;/code&gt;&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;我们已经看到了两种修改commit指针的方式：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git checkout&lt;/code&gt;移动&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;指针&lt;/li&gt;
&lt;li&gt;用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git branch -f &amp;lt;branch&amp;gt; &amp;lt;目标commit&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果目标地址不是某个branch而是一个commit，我们必须找到其ID，这通常比较麻烦。我们可以用 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;^&lt;/code&gt; 和 &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;~&lt;/code&gt; 相对某个指针进行定位：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;HEAD^ &lt;span style=&quot;color: #75715e;&quot;&gt;# HEAD之前的commit&lt;/span&gt;
HEAD^^ &lt;span style=&quot;color: #75715e;&quot;&gt;# HEAD回退两步的commit&lt;/span&gt;
master~&lt;span style=&quot;color: #ae81ff;&quot;&gt;5&lt;/span&gt; &lt;span style=&quot;color: #75715e;&quot;&gt;# master指针回退5步的commit&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;撤销提交&lt;/h4&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;1. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;reset&lt;/code&gt;&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;reset 的作用是移动当前分支。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git reset HEAD^ &lt;span style=&quot;color: #75715e;&quot;&gt;#将当前分支往回退一步&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;它的效果和&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git branch&lt;/code&gt;移动分支是一样的：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git branch &lt;span&gt;-f&lt;/span&gt; master HEAD^ &lt;span style=&quot;color: #75715e;&quot;&gt;# master是当前分支&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;注意，文件的内容会被保留，你会发现多了很多未暂存的文件修改，利用这一点我们可以用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git reset&lt;/code&gt;整理commit历史，将多个commit合并为1个。如果想让所有文件彻底回到目标commit的状态，可以再次&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;$ git checkout .&lt;/code&gt;丢弃所有文件修改；或者给&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;reset&lt;/code&gt;加上&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;--hard&lt;/code&gt;参数，这样你的本地修改都会被抹杀，大招慎用。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;2. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;revert&lt;/code&gt;&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;revert 为指定的（多个）提交生成逆操作，并依次形成新的commit：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git revert HEAD&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;效果： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1429632759910.png&quot; name=&quot;7816a4e9-c1f0-4b39-8cc6-86c859ac294f&quot; src=&quot;/assets/img/1668c449782266c97fe5be683d1de91c.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;  ==&amp;gt; &lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1429632817596.png&quot; name=&quot;377cde64-6313-4b26-b3da-62c18935a52b&quot; src=&quot;/assets/img/4024a57ffefd45ffb1e049bd36dd8f51.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt; &lt;br/&gt;
C2被撤销了。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;比&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;reset&lt;/code&gt;好在可以把撤销动作push到远程分支，共享给其他开发者。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;随意移动commit&lt;/h4&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;1. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;cherry-pick&lt;/code&gt;&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这命令名字很长但其实很简单，就是把指定的几个commit拷贝一份，append到HEAD后面，比如：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;$ git cherry-pick C2 C4&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430032079563.png&quot; name=&quot;4dda4a03-65f9-4029-9d50-2598a6d46c0a&quot; src=&quot;/assets/img/27e065839cde79c86a95eca5532fe04e.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt; ==&amp;gt; &lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430032097845.png&quot; name=&quot;f9f0d8d3-6a5f-4222-a158-b4cffd38767b&quot; src=&quot;/assets/img/203e9f331c55a7f03b791bee2ff9cd07.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;2. &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase -i&lt;/code&gt;&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该命令提供了一个交互式的界面（说是界面其实用VI打开个文本文件）让你整理最近的若干次提交，你可以在这里对 commit 进行删除、合并、重排序，是整理commit历史的利器。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;比如你现在有3次提交，分别是&lt;em&gt;first/second/third&lt;/em&gt;，&lt;em&gt;third&lt;/em&gt;是最后一次提交。输入以下命令：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;git rebase -i HEAD~&lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD~3&lt;/code&gt;表明修改对象是从&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD~3&lt;/code&gt;开始（不包括自己）到&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HAED&lt;/code&gt;的3个commit。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;然后出来一个文本文件让你编辑，怎么编辑有注释告诉你：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;pick &lt;span style=&quot;color: #ae81ff;&quot;&gt;65&lt;/span&gt;bc434 first
pick &lt;span style=&quot;color: #ae81ff;&quot;&gt;86253&lt;/span&gt;cb second
pick b2756fa third

&lt;span style=&quot;color: #75715e;&quot;&gt;# Rebase ab14c02..b2756fa onto ab14c02 (3 command(s))&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;#&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# Commands:&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# p, pick = use commit&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# r, reword = use commit, but edit the commit message&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# e, edit = use commit, but stop for amending&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# s, squash = use commit, but meld into previous commit&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# x, exec = run command (the rest of the line) using shell&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;#&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# These lines can be re-ordered; they are executed from top to bottom.&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;#&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# If you remove a line here THAT COMMIT WILL BE LOST.&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;#&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# However, if you remove everything, the rebase will be aborted.&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;#&lt;/span&gt;
&lt;span style=&quot;color: #75715e;&quot;&gt;# Note that empty commits are commented out&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;假如我们想把second和third合并为一个commit &lt;em&gt;new&lt;/em&gt; ，再把first丢在new的后面，应该这么搞：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;pick &lt;span style=&quot;color: #ae81ff;&quot;&gt;86253&lt;/span&gt;cb second &lt;span style=&quot;color: #75715e;&quot;&gt;#选择second&lt;/span&gt;
s b2756fa third &lt;span style=&quot;color: #75715e;&quot;&gt;#s：合并到上一个commit&lt;/span&gt;
pick &lt;span style=&quot;color: #ae81ff;&quot;&gt;65&lt;/span&gt;bc434 first &lt;span style=&quot;color: #75715e;&quot;&gt;#选择first&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;整个过程其实是 &lt;strong style=&quot;font-weight: bold;&quot;&gt;先将分支回退到指定位置（这里是&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD~3&lt;/code&gt;）然后依次执行上面的命令&lt;/strong&gt;：第一二行把second和third合并为一个提交，并让你编辑这个新提交的commit message： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430037853286.png&quot; name=&quot;4d76c9a2-a508-420a-babd-15c63cefd54f&quot; src=&quot;/assets/img/c4e5eb5760023e46167c1ef179d9bbe4.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;第三行提交first，同样也能编辑commit信息，截图就不放了。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;远程&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;远程分支是远程版本库中分支在本地的镜像，反应了远程库中分支的状态，是&lt;strong style=&quot;font-weight: bold;&quot;&gt;本地库与远程库交互的桥梁&lt;/strong&gt;。它们和本地分支没什么不同，只不过在某种意义上远程分支是“只读”的：你通常不会手动去操作远程分支，只会通过与服务器的“推送”和“拉取”动作来更新它们；而且也无法把&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HEAD&lt;/code&gt;指针和远程分支绑定（attach）在一起。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;clone&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git clone&lt;/code&gt;从远程主机中克隆一个版本库到本地，git 将做以下动作：&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;远程库被命名为 origin；&lt;/li&gt;
&lt;li&gt;将远程库的所有数据（分支、提交历史）拷贝到本地，远程库中的每个分支以一个远程分支的形式存在（名称为&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;远程主机名/分支名&lt;/code&gt;，如&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;origin/master&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;以远程库中的当前分支为基准，创建一个同名的本地分支，方便你进行后续工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;可以用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git branch -r&lt;/code&gt;查看远程分支，&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;-a&lt;/code&gt;查看所有分支：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git branch &lt;span&gt;-a&lt;/span&gt;                                                
* master
  remotes/origin/HEAD -&amp;gt; origin/master
  remotes/origin/Task_Description_Display
  remotes/origin/Task_Description_Edit
  remotes/origin/master&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;以一个远程分支为基准创建本地分支的方式和之前一样：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git checkout origin/dev &lt;span style=&quot;color: #75715e;&quot;&gt;#移动HEAD指针到远程分支（进入detached HEAD模式）&lt;/span&gt;
&amp;gt; git branch dev &lt;span style=&quot;color: #75715e;&quot;&gt;#创建新分支dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git remote&lt;/code&gt; 用来管理远程库，不太常用，一般用默认的 origin 就够了：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git remote show &amp;lt;远程库&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#看地址&lt;/span&gt;
&amp;gt; git remote add &amp;lt;远程库&amp;gt; &amp;lt;地址&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#加&lt;/span&gt;
&amp;gt; git remote rm &amp;lt;远程库&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#删&lt;/span&gt;
&amp;gt; git rename &amp;lt;远程库&amp;gt; &amp;lt;新名字&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;#重命名&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;fetch&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果远程库有了更新，可以用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git fetch&lt;/code&gt;将更新拉取到本地，并将对应的远程分支（即 origin/master 等指针）移动到最新位置。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git fetch &amp;lt;远程库&amp;gt;   &lt;span style=&quot;color: #75715e;&quot;&gt;# 取所有分支的更新，如果远程库有新的分支，本地会创建对应的远程分支&lt;/span&gt;
&amp;gt; git fetch -p &amp;lt;远程库&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;# 同上，但会删除远程库中已不存在的远程分支，p==prunge&lt;/span&gt;
&amp;gt; git fetch &amp;lt;远程库&amp;gt; &amp;lt;分支名&amp;gt; &lt;span style=&quot;color: #75715e;&quot;&gt;# 取特定分支的更新&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git fetch&lt;/code&gt;只会更新远程分支，不会影响本地分支。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;pull&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull&lt;/code&gt; == &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git fetch&lt;/code&gt; + &lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git merge&lt;/code&gt;：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;先从远程库拉取数据更新某个远程分支，再与指定本地分支进行merge。完整格式：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git pull &amp;lt;远程库&amp;gt; &amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;
&amp;gt; git pull origin next:master &lt;span style=&quot;color: #75715e;&quot;&gt;# 更新origin/next，与master分支合并&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果省略&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;&amp;lt;本地分支&amp;gt;&lt;/code&gt;（&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull origin &amp;lt;远程分支&amp;gt;&lt;/code&gt;），则与当前分支合并。如果当前分支与远程分支是 &lt;em&gt;tracking&lt;/em&gt;关系，则&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull&lt;/code&gt;即可，省略所有参数。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Tracking Branch&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;本地分支和远程分支间可以建立一种跟踪(Tracking)关系，这样的本地分支被称为 Tracking Branch。在跟踪分支上进行&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull&lt;/code&gt;或&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git push&lt;/code&gt;，Git会自动判断应向远程库中的哪个分支拉取/推送数据。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git clone&lt;/code&gt;时会自动为 &lt;em&gt;新建的本地分支&lt;/em&gt; 与 &lt;em&gt;对应远程分支&lt;/em&gt; 之间建立跟踪关系，这也是为什么克隆完成后&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull/push&lt;/code&gt;直接可用的原因。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;可以用下面的命令手动建立跟踪关系：&lt;/p&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git branch -u &amp;lt;远程分支&amp;gt; &amp;lt;本地分支&amp;gt;
或者
&amp;gt; git branch --set-upstream-to=&amp;lt;远程分支&amp;gt; &amp;lt;本地分支&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果合并远程分支时不想用默认的&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;merge&lt;/code&gt;而是&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;rebase&lt;/code&gt;，可以加上&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;--rebase&lt;/code&gt;参数：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git pull --rebase &amp;lt;远程库&amp;gt; &amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;push&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;将某个本地分支上的更新推送到远程库中的某个分支，完整格式：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git push &amp;lt;远程库&amp;gt; &amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果省略&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;&amp;lt;本地分支&amp;gt;&lt;/code&gt;（&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git push origin &amp;lt;远程分支&amp;gt;&lt;/code&gt;），则把当前分支推送到远程库中的指定分支，无则新建。如果当前分支有且只有一个跟踪的远程分支，不带参数的&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git push&lt;/code&gt;即可。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git push&lt;/code&gt;还用来删除远程库中的分支，方法是&lt;strong style=&quot;font-weight: bold;&quot;&gt;将一个空白的分支推送到指定分支&lt;/strong&gt;：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git push origin :master &lt;span style=&quot;color: #75715e;&quot;&gt;#把远程库中的master分支删掉&lt;/span&gt;
等同于
&amp;gt; git push origin --delete master&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这个需求很常见而命令又很奇怪，很容易忘记。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;不带参数的&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git push&lt;/code&gt;默认只推送当前分支，这成为“simple”方式；还有一种“matching”方式推送所有分支。2.0后默认是simple，可以用如下命令更改：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&amp;gt; git config --global push.default simple&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果远程库中分支的版本比本地更新，push时会报错，必须先在本地fetch，解决冲突并合并后再push。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;加&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;-f&lt;/code&gt; (force)选项可以用本地分支强制覆盖远程库中的分支。在整理提交历史时这个选项很有用，比如你刚做了两次提交并把它们push到了远程库中，现在你想把它们合并为一次，对本地分支可以用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git rebase -i&lt;/code&gt;或者&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git reset&lt;/code&gt;达到目的，但你无法把合并后的commit推送到远程库，这时可用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;-f&lt;/code&gt;把你整理后的本地分支强制推送过去。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;常见GIT工作流&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;集中式&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430108058631.png&quot; name=&quot;75777236-40df-4260-8d9c-7976ef133673&quot; src=&quot;/assets/img/64d163dec7d1e7ae93d376ae01f14e8b.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;和传统SVN类似，只有一个远程库，开发者把库克隆到本地，进行修改再推送回去。库有更新了则先拉取下来进行合并，有冲突则解决冲突。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;简单实用，小型团队这么干就够了。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Forking 工作流&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在Forking工作流下，通常有一个由专人维护的官方仓库，开发者们没有官方仓库的push权限，而是先从官方仓库fork一份私有库，开发工作都在该库上进行，开发完毕后向官方仓库发起一个pull request，请求从自己的私有库中拉取更新合并到官方库。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Forking工作流的一个主要优势是不用开放官方仓库的push权限给第三方。开发者push到自己fork出来的私有库，只有项目维护者才能push到正式仓库。这样项目维护者可以接受任何开发者（包括不受信的第三方）的提交，而不用开放官方仓库的写权限给他。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step1&lt;/strong&gt;：维护者建立官方仓库，假设只有一个分支master&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430117288018.png&quot; name=&quot;d42e02a5-a55e-4a06-b214-220f1a3a5426&quot; src=&quot;/assets/img/b97e977f8b827962608d5dc0a9b27822.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step2&lt;/strong&gt;：开发者fork一个自己的私有库，一般会在fork时勾选同步，这样Git服务器（github或stash）会自动将官方仓库的更新同步过来：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430117646167.png&quot; name=&quot;223d316d-3a0a-4bd7-bd55-68a044f55067&quot; src=&quot;/assets/img/cd0e58344cab3019fdb42ab400eb167f.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step3&lt;/strong&gt;：开发者clone自己fork的库，并在新分支上（如dev）进行开发工作，开发完毕将其push到私有库的dev分支，私有库的master分支用于同步官方仓库，不直接修改：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430117815702.png&quot; name=&quot;156dd713-ad9f-49c7-904f-5108d184cebb&quot; src=&quot;/assets/img/11326c2fab04c269e4a42c8c37aea781.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step4&lt;/strong&gt;：开发者创建一个pull request，通知维护者将自己私有库中的分支合并到官方仓库中：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430118213821.png&quot; name=&quot;0f414936-91be-451c-848f-d2e901259c9e&quot; src=&quot;/assets/img/26266e4567b95a93e9586052fb342256.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Stash 中创建pr的表单如下，你需要指定要将自己库中的哪个分支推送到官方库中的哪个分支，本例中是dev推送到master： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430118017839.png&quot; name=&quot;5d3b23c7-fe10-430f-885e-31c3b0dacb44&quot; src=&quot;/assets/img/1ebf158e129d86a327266327a14ba7ec.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step5&lt;/strong&gt;：官方仓库的维护者收到pr后决定是否接受。Stash提供了GUI界面，维护者可以直接在网站中查看pr的代码修改、与开发者进行讨论，最后执行合并。接受pr的效果相当用&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;git pull&lt;/code&gt;命令拉取开发者仓库分支（dev）并merge到官方仓库分支（master），这也是 “pull request” 名称的由来。如果出现了冲突，维护者必须在本地从开发者仓库中fetch分支，合并到本地分支master，并解决冲突，最后将代码push到官方仓库：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430118926103.png&quot; name=&quot;2300a2a9-3c22-46d5-8cf6-e7fb0c40160f&quot; src=&quot;/assets/img/eee8dca00fb4737eb882b3baf3cfae7c.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;word-break: break-word; font-family: &#39;Source Code Pro&#39;,monospace; white-space: pre-wrap; display: block; background-color: rgba(102,128,153,0.05); color: #333; line-height: 1.45; font-size: .9em; word-wrap: break-word; background: #f6f6f6; margin: 0 0 1.1em; padding: 2px; border: 0; border-radius: 5px; text-align: start;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: &#39;Source Code Pro&#39;,monospace; font-size: inherit; background-color: transparent; white-space: pre-wrap; border-radius: 0; color: #f8f8f2; display: block; background: #23241f; padding: 18px 28px;&quot;&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;# 拉取开发者仓库中的分支&lt;/span&gt;
&amp;gt; git fetch https://bitbucket.org/user/repo feature-branch
&lt;span style=&quot;color: #75715e;&quot;&gt;# 查看变更&lt;/span&gt;
&amp;gt; git checkout master
&lt;span style=&quot;color: #75715e;&quot;&gt;# 解决冲突并合并&lt;/span&gt;
&amp;gt; git merge FETCH_HEAD
&amp;gt; git push origin master&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Step6&lt;/strong&gt;：官方仓库的master分支向前走了，开发者私有仓库中的master分支会自动同步，开发者将最新代码pull到本地：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1430119179264.png&quot; name=&quot;6a91b9cb-affd-4e66-9ae8-189c116db2c9&quot; src=&quot;/assets/img/ac6870ef0627b403e2501bf4129b9cd5.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;Tips&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Mac下的图形化Git：gitx；&lt;/li&gt;
&lt;li&gt;Ubuntu下的图形化Git：gitg；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/76861/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Git工作流指南：Forking工作流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Pro Git》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Learn Git Branching&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>常用设计模式的总结</title>
      <link>http://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/04/02/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html</link>
      <pubDate>02 Apr 2015</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/04/02/常用设计模式的总结</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;常用设计模式的总结&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;一. 创建型模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. Factory method 工厂方法&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. Abstract factory 抽象工厂&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. Singleton 单例&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. Builder&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;交互&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;二. 结构型模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. Adapter 适配器&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. Proxy 代理&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;与Decorator模式的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. Bridge 桥接模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. Decorator 装饰者&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;5. Composite 组合模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;6. Facade&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;三. 行为模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. Chain of Responsibility 责任链&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;应用&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;标准责任链&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;扩展（功能链）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. Command 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. Memento 备忘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. Observer 观察者&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;扩展：EventBus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;5. State 状态模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;6. Strategy 策略模式&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;7. Template Method 模板方法&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;四. 设计原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;一. 创建型模式&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;1. Factory method 工厂方法&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一个类需要一个产品来完成某项工作，但它不能确定，也不关心具体拿到什么产品，因此它定义一个工厂方法，将具体产品的生产延迟到子类决定。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403160006818.png&quot; name=&quot;815b1ae9-fa42-45c7-8ce1-1e3cfa9697eb&quot; src=&quot;/assets/img/18beee5db7b6bd0a8be14199eaa9289e.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;父类可以选择为工厂方法提供一个默认的实现；&lt;/li&gt;
&lt;li&gt;工厂方法通常在模板方法（Template method）中被调用，上图中&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;AnOperation()&lt;/code&gt;就是一个模板方法。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2. Abstract factory 抽象工厂&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;系统有一组相互关联的产品接口，及几套不同的实现。客户只依赖产品接口，并需要能灵活地在几套实现中切换。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因此提供一个抽象工厂生产抽象的产品，每个产品在其中都对应一个工厂方法，产品族的每一套实现都提供一个具体工厂。客户通过抽象工厂获取产品，当需要切换到产品的其他实现时只需要更换工厂的实现类。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403146746942.png&quot; name=&quot;cc1f550b-d3ac-4847-91d6-df55775dcbe5&quot; src=&quot;/assets/img/035462ec043438b6758dcf27783ac846.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;应用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;根据底层数据源的不同，DAO的实现通常有几套，当切换数据源时，系统使用的DAO的实现也应当能快速切换。这是使用抽象工厂的一个典型场景。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;3. Singleton 单例&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;保证一个类只有一个对象&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;private&lt;/code&gt;构造器&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;private static&lt;/code&gt; 类变量 singleton&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;public static&lt;/code&gt; 类方法 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;getInstance()&lt;/code&gt; 返回singleton。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;实例化时机：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;eager&lt;/li&gt;
&lt;li&gt;lazy&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;lazy init 多线程问题的解决办法：&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Double Check&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;volatile&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;static&lt;/span&gt; A singleton = &lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;;

&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #66d9ef;&quot;&gt;static&lt;/span&gt; A &lt;span style=&quot;color: #a6e22e;&quot;&gt;getInstance&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;(singleton == &lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;){
        sychronized(A.class){
            &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;(singleton == &lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;) singleton = &lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; A();
        }
    }
    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; singleton;
}

&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;/code&gt;&lt;/pre&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;为什么要第二次的null判断？ &lt;br/&gt;
在第一次判null / 获取锁之间可能有其他线程实例化了。&lt;/li&gt;
&lt;li&gt;为什么要&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;volatile&lt;/code&gt;？ &lt;br/&gt;
在上面提到的情况下，如果没有&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;volatile&lt;/code&gt;保证的可见性，在第二次null判断时当前线程可能看不到别的线程创建的对象，从而通过并再创建一次。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;static 内部类&lt;/code&gt;利用 “类的加载/static块是线程安全的” 实现线程安全的lazy init：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;public&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: #a6e22e; font-style: italic;&quot;&gt;A&lt;/span&gt;&lt;/span&gt;{
    &lt;span style=&quot;color: #f92672;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;static&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: #a6e22e; font-style: italic;&quot;&gt;Holder&lt;/span&gt;&lt;/span&gt;{
        &lt;span style=&quot;color: #f92672;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;static&lt;/span&gt; A singleton = &lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; A();
    }

    &lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #66d9ef;&quot;&gt;static&lt;/span&gt; A &lt;span style=&quot;color: #a6e22e;&quot;&gt;getInstance&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; Holder.singleton;
    }

    &lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;4. Builder&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;你有一个产品，该产品由若干part装配而成，装配的逻辑是固定的，但各个part的构造是可切换选择的，Builder模式将 &lt;strong style=&quot;font-weight: bold;&quot;&gt;固定的装配逻辑&lt;/strong&gt; 与 &lt;strong style=&quot;font-weight: bold;&quot;&gt;易变的part构造逻辑&lt;/strong&gt; 分离开，可以方便地在不同的part实现逻辑之间切换。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403163234482.png&quot; name=&quot;f2f52c32-904f-4005-b469-6ceab218cb79&quot; src=&quot;/assets/img/c0a3a2c8ac96ae2b632840adff485541.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Director#construct()&lt;/code&gt; 负责固定的装配逻辑；&lt;/li&gt;
&lt;li&gt;一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Builder&lt;/code&gt;实例负责一个产品内部所有part的构造（&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;buildPart()&lt;/code&gt;方法族），并向外部暴露方法，在part都装配完毕后获取该产品。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;交互&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403163378411.png&quot; name=&quot;401a0656-67ee-4ad6-8884-bba562877f1b&quot; src=&quot;/assets/img/48bc1c5fd3e8b0feb1c8376c2624881b.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr style=&quot;-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;&quot;/&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;二. 结构型模式&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;1. Adapter 适配器&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在两个不兼容的接口之间加一个中间层，用组合的方式将一个现有对象匹配到需要的接口。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;Convert the interface of a class into another interface the client expects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403164872248.png&quot; name=&quot;b2280c71-73c2-44eb-b3eb-daeb3b69ed07&quot; src=&quot;/assets/img/c064c439075e2763de2e671525b1eda6.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2. Proxy 代理&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;Provide a surrogate or place holder for another object to control access to it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;你有一个真正干活的对象RealSubject，但需要向client控制对他的访问，比如权限的控制 / Lazy load / 结果的缓存等等，因此在client和RealSubject之间增加一个中间层Proxy代替RealSubject，Proxy包裹RealSubject，将具体功能实现委托给它，并在RealSubject执行真正的功能前后插入自己的逻辑；此外，Proxy向client隐藏了RealSubject的存在。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403416618628.png&quot; name=&quot;4da066cf-ad1c-4575-b5b6-e673befd26f6&quot; src=&quot;/assets/img/f1d237241de80e592a429463c570401b.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;与&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator&lt;/code&gt;模式的区别&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Proxy与Decorator有着相似的结构，&lt;em&gt;* 他们都在client和真实对象之间增加一个与真实对象实现了相同接口的中间层，这个中间层保留了对真实对象的引用并向他们发送请求*&lt;/em&gt;。然而他们的设计目的是不同的：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Decorator侧重动态为实体增加功能，因此在该模式中：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;实体只实现了部分功能，Decorator实现了其他的增强功能；&lt;/li&gt;
&lt;li&gt;支持递归组合（增加多重功能）；&lt;/li&gt;
&lt;li&gt;Decorator不知道自己装饰的是哪个具体对象，client必须自己手动将实体和Decorator关联起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Proxy的目的则是当访问一个特定实体不方便或不符合要求时，为这个实体提供一个替代者，因此：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;实体实现了关键功能，Proxy提供（或拒绝）对它的访问；&lt;/li&gt;
&lt;li&gt;不支持递归组合；&lt;/li&gt;
&lt;li&gt;Proxy向client屏蔽RealSubject的存在，client只能拿到Proxy；&lt;/li&gt;
&lt;li&gt;Proxy确定地知道自己的代理目标是RealSubject，因此它和RealSubject相关联而不是Subject接口；此外，它们的关系是静态的，无法在运行时改变Proxy代理的目标对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;3. Bridge 桥接模式&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;你有一个产品，它在两个维度上都是可变化的，如果用继承，则需要n*m个子类。Bridge模式将两个维度的继承体系独立出来，并在二者之间用组合进行装配，避免类的泛滥。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;进一步地考虑，一个产品的继承体系应该只有一个维度，如果出现了其他维度上的继承，要考虑该维度是否是行为/实现相关的。对于行为/实现方面的变化，应当先把行为独立地抽象出来，并与原产品&lt;strong style=&quot;font-weight: bold;&quot;&gt;组合&lt;/strong&gt;（这就是&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;的含义），而不应该直接在原产品上通过继承表达该行为的变化。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;举个例子，假如系统内要发送消息，消息按迫切程度分为普通/加急/特急，消息的发送形式也可以多样，比如站内信/短信/email，每种消息都要求可以用任意方式发送：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403166907142.png&quot; name=&quot;ef3fdeb5-1eb1-46f4-90a8-63b4df7dd9af&quot; src=&quot;/assets/img/847c1c498fbe0949cea6d1e54529116c.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果简单地用继承，则需要3*3 = 9个类。但实际上，&lt;em&gt;消息的发送&lt;/em&gt; 这个维度属于行为，&lt;strong style=&quot;font-weight: bold;&quot;&gt;不要用继承来表达行为的变化，这样会污染原本的抽象层次&lt;/strong&gt;，应当用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;将 &lt;em&gt;消息发送&lt;/em&gt; 这个行为分离。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;采用Bridge模式： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403168007802.png&quot; name=&quot;ec69d397-81eb-4e54-bf0f-caccd04c8b82&quot; src=&quot;/assets/img/26bd87f9aac60b903429a043f5267fe2.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403167837240.png&quot; name=&quot;19482432-6997-47bf-abf5-09d94692ad6d&quot; src=&quot;/assets/img/f575f921b45b33e766d4996850d57f51.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;产品的抽象 + 行为的分离（&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;）&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;总结&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Bridge模式在我看来是对&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;的扩展，它的核心有两点：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;只在一个维度上用继承，出现了多个维度则考虑分离并用组合，避免类的泛滥和抽象维度的混杂；&lt;/li&gt;
&lt;li&gt;用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;隔离行为的变化，不要让行为/实现的变化污染原本的继承体系。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;4. Decorator 装饰者&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;有一系列产品，你希望动态地为他们添加额外 / 可自由组合 的功能，并且不影响产品本身。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;Attach additional responsibilities to an object dynamically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403176265661.png&quot; name=&quot;608e2ade-e005-4f88-a483-30f3464db3db&quot; src=&quot;/assets/img/30afda5a1ce0b38a24ddf91ab1cc35fd.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator 装饰器&lt;/code&gt;继承产品抽象接口，并在内部持有一个产品（可能是具体产品，也有可能被装饰过了）；&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator&lt;/code&gt;的具体实现，为其装饰的产品提供额外的功能，类似递归的调用；&lt;/li&gt;
&lt;li&gt;可以同时反复应用多个 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator&lt;/code&gt; ，实现额外功能的动态组合。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;应用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;1. &lt;br/&gt;
java的IO流的设计是一个典型的装饰者模式： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403176954152.png&quot; name=&quot;5c5975fd-71df-48c5-9d30-1639cb018042&quot; src=&quot;/assets/img/0b3cd16d7a13a3595c5d2ce4bc8e7989.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ByteArrayInputStream | FileInputStream | ObjectInputStream | StringBufferInputStream&lt;/code&gt;是具体的输入流产品，根据数据来源区分； &lt;br/&gt;
&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;FilterInputStream&lt;/code&gt;是装饰器； &lt;br/&gt;
&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;BufferedInputStream | DataInputStream | LineNumberInputStream | PushbackInputStream&lt;/code&gt;是具体的装饰器，分别为其他输入流提供缓冲/类型读写/跟踪行号/退回已读数据的功能，这些装饰器是可以组合使用的：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;InputStream in = &lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; DataInputStream(&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; BufferedInputStream(&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;test.txt&quot;&lt;/span&gt;))); &lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;2. &lt;br/&gt;
&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator模式&lt;/code&gt;也可以用来实现&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;AOP&lt;/code&gt;的类似功能（虽然实际大部分都是用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;JDK动态代理 / 运行时修改字节码&lt;/code&gt;），&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Decorator&lt;/code&gt;的具体实现就是我们想要独立出来的切面，产品的具体实现则是我们想要保持独立的业务逻辑。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;5. Composite 组合模式&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;实现树形结构，并让用户可以用统一的接口对待叶子节点和非叶子节点。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403178780524.png&quot; name=&quot;798cd136-1a17-4043-bbbc-252aa7309666&quot; src=&quot;/assets/img/209632dd71560ad008afa322afcd4a8b.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;操作孩子的方法应该放在Component中吗？毕竟Leaf是不支持这些操作的。 &lt;br/&gt;
出于透明性考虑，应该放在Component中，Leaf对这些方法就提供一个空的实现。&lt;/li&gt;
&lt;li&gt;Component除了保存孩子，也可以记录父亲；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;应用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;UI / 人员组织管理这种典型的树形结构中用的比较广泛。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;6. Facade&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一个系统对外提供服务，系统暴露的接口应该是简单而统一的，客户不应该直接和系统内复杂的子部件进行交互，而应只依赖于一个单一的高层接口，该组件为客户屏蔽了内部的复杂性，降低了客户和系统的耦合。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403180072180.png&quot; name=&quot;51a5345e-8878-45e3-be1d-f107fe8e299a&quot; src=&quot;/assets/img/614a5339a4bc9e877faba8860023bd7e.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;更像是一种设计思路，而非一个具体模式。&lt;/p&gt;
&lt;hr style=&quot;-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;&quot;/&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;三. 行为模式&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;1. Chain of Responsibility 责任链&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;客户端发出一个请求，有一系列的处理器都有机会处理这个请求，但具体哪个是运行时决定的，客户端也不知道究竟谁会来处理。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因此将所有处理器组成一个链条，将请求从链条中流过，每个处理器查看是否应该处理它，如果不是，则交给后面的处理器，否则处理并退出。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;将请求者和处理者解耦，可以动态切换/组合处理者。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403243902492.png&quot; name=&quot;865e77db-ace2-4ec6-a785-efa647309a64&quot; src=&quot;/assets/img/a56fee528e339c6613e30648efbef87c.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;扩展&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;客户端发出一个请求，请求的处理分为很多步骤，这些步骤是不确定的/可以动态组合的，甚至需要支持在运行时改变步骤，或者在步骤间任意跳转。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;解决方案和责任链类似，将处理流程抽象为一个处理器链条，链条的组装交给外部决定。每个处理器对请求完成自己负责的业务逻辑，并看情况结束/传递给下一个处理器/跳转到任意处理器。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这和标准的责任链的结构基本一样，但他们的目的不一样。标准责任链目的是动态 &lt;strong style=&quot;font-weight: bold;&quot;&gt;找到请求的处理者&lt;/strong&gt; ；扩展（某些地方称为“功能链”？）则是为了获取 &lt;strong style=&quot;font-weight: bold;&quot;&gt;动态拼装和改变处理流程&lt;/strong&gt; 的能力。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;应用&lt;/h4&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;标准责任链&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;UI中的事件冒泡机制是责任链的一个典型应用。HTML中，点击一个DOM元素，产生的click事件将依次冒泡给它的父元素，每个父元素上都可以注册对click事件的监听器，监听器中除了对事件处理外，也可以结束事件的继续冒泡。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;扩展（功能链）&lt;/h5&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Web应用中的各种filter/拦截器；&lt;/li&gt;
&lt;li&gt;Netty中的pipeline&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2. Command 命令&lt;/h3&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;你需要向一个对象提交请求，但对请求的处理是动态的，无法写死。比如一个菜单项，在不同的上下文中，点击它要做的事情显然是不一样的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Command模式的思路是 &lt;em&gt;抽象请求(及处理)&lt;/em&gt;：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403330120754.png&quot; name=&quot;54ec3d42-3a0e-40df-b379-796fcbadc5d6&quot; src=&quot;/assets/img/3b17f754f940a0f0fe4ba7ab42d3bf7b.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Client&lt;/code&gt; 装配 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Invoker&lt;/code&gt; 和 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Command&lt;/code&gt;，&lt;em&gt;* 如果需要不同的处理，装配不同的Command即可 *&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Client&lt;/code&gt; 向 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Invoker&lt;/code&gt; 发出请求;&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Invoker&lt;/code&gt; 将请求的处理委托给 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Command#execute()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;很多时候Command不够智能，自己无法处理请求，需要将请求委托给另一个Receiver进行真正的处理，ConcreteCommand可以认为是Receiver的适配器：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403330618542.png&quot; name=&quot;12ffea50-afe4-4721-b820-028fa7e9ef9b&quot; src=&quot;/assets/img/218e4d5340a7128621b66317a0231de9.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;可以看到，Command模式的最大价值在于：隔离 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;请求的接收者&lt;/code&gt; 和 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;请求的处理逻辑&lt;/code&gt;； &lt;br/&gt;
此外，将请求及其处理逻辑抽象为Command后可以做很多有意思的事情：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;1. 可撤销的操作&lt;/strong&gt; &lt;br/&gt;
在Command接口中增加一个接口 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;undo()&lt;/code&gt; 实现单个命令的撤销动作，并用一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;stack&lt;/code&gt;保存所有Command；当用户触发撤销时依次从stack pop出最近的Command，执行其&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;undo()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;2. 宏命令&lt;/strong&gt; &lt;br/&gt;
宏命令实质是个树形结构，对Command应用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Composite 组合模式&lt;/code&gt;即可实现：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403331500067.png&quot; name=&quot;e7847b4f-41bf-4119-a951-4d624dba8667&quot; src=&quot;/assets/img/dc457220d36c915d5e2029e38450f985.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;3. 排队&lt;/strong&gt; &lt;br/&gt;
&lt;strong style=&quot;font-weight: bold;&quot;&gt;4. 日志记录和恢复&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;3. Memento 备忘录&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;有些情况下你需要记录一个对象（称为&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Originator&lt;/code&gt;）在某个时刻的状态（snapshot），以便后续恢复，我们可以用一个类&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt;表示snapshot，它包含了Originator的部分或全部状态：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403337566655.png&quot; name=&quot;be9e3e1d-4218-44e6-8a2e-3d97bc30a012&quot; src=&quot;/assets/img/9c6a8340acd50dba1917c3cf4a125982.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Originator 负责创建Memento，以及恢复到某个Memento；&lt;/li&gt;
&lt;li&gt;Memento 即Originator的snapshot；&lt;/li&gt;
&lt;li&gt;Caretaker 充当协调者，它负责向Originator请求当前Memento / 保存Memento / 在后续某个时刻让Originator恢复到某个Memento。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;但这里有一个问题，为了隐藏Originator的实现细节，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt;必须向外部隐藏内部数据，即不开放&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;state&lt;/code&gt; 的 getter/setter 给外部，但这样一来，Originator也无法创建&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt;了。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;为了解决这个问题，在Memento模式的一般实现中，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt; 类被分为两个部分：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403338095772.png&quot; name=&quot;5674e674-3a18-4f78-99e7-6a7f92fba97a&quot; src=&quot;/assets/img/3d7987515415ba78f3ea820f2f1bc8e0.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;标记接口 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt;，空的，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Caretaker&lt;/code&gt;只能得到这个接口；&lt;/li&gt;
&lt;li&gt;Memento的真正实现&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;MementoImpl&lt;/code&gt;，作为&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Originator&lt;/code&gt;的 &lt;strong style=&quot;font-weight: bold;&quot;&gt;私有内部类&lt;/strong&gt; ，这样既允许Originator访问Memento的内部状态，又满足了Memento向外部（主要是Caretaker）隐藏内部细节的要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果对 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Memento&lt;/code&gt; 的封装性没有严格的要求，第一种实现显然更简单。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;4. Observer 观察者&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;定义一个一对多关系，在Subject状态发生改变时，所有Observer获得通知。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;解耦 事件发生者 &amp;amp; 事件接收者，使得双方的改动互不影响，关联关系也可动态改变。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403418566851.png&quot; name=&quot;7c703bde-46c8-40ab-b902-80c8c0896ee8&quot; src=&quot;/assets/img/dce2e441e24a27dc6a4c0ca8d82d0e41.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;数据传递的两种方式：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;推：由 Subject 主动向 Observer 推送信息，而不管信息对后者而言是否需要/是否足够。&lt;/li&gt;
&lt;li&gt;拉：Subject 把自己传递给 Observer，由 Observer 从 Subject 拉取自己需要的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;扩展： Observer 注册时可以指定自己感兴趣的事件。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;扩展：EventBus&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;传统的Observer模式中，事件发生者和接收者依然存在耦合，发生者需要管理接收者的集合，我们可以进一步地，在Subject和Observer间增加一个中间层负责转发事件，将它们彻底地解耦；进一步，这个事件转发者可以是通用的，支持任意发布者和接受者，通常称之为&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;EventBus&lt;/code&gt;，是一种广泛应用的架构。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;5. State 状态模式&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;模拟状态机，描述一个对象（Context）的状态变迁，将特性状态下的行为分割开来，避免在Context中用大量的if维护所有状态的变迁，而且容易扩展新的状态。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403425126082.png&quot; name=&quot;4c50c831-800a-498b-b553-aa9bdbae3443&quot; src=&quot;/assets/img/06380860aa7c8cbaf8c29f204a4b5829.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Context&lt;/code&gt;中记录它自己当前的状态；&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Context&lt;/code&gt;接收一个输入动作，并将该输入委托给当前所处&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;State&lt;/code&gt;处理；&lt;/li&gt;
&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;State&lt;/code&gt;处理输入，根据需要让&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Context&lt;/code&gt;跃迁到另一状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;State&lt;/code&gt;不保存状态则可以是单例的，Java中，可以用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;enum&lt;/code&gt;类型实现&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;State&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;6. Strategy 策略模式&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;你有一个对象负责完成某件事情，但在不同时刻其使用的算法是不同的，Strategy模式将可变的算法独立并封装，避免大量if条件判断，并方便替换和扩展。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Strategy&lt;/code&gt; 封装了 &lt;strong style=&quot;font-weight: bold;&quot;&gt;相同行为的不同实现&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403426300530.png&quot; name=&quot;cf367d7d-c611-4531-9aad-9ca5a3b18527&quot; src=&quot;/assets/img/268d5cd27f08e90d9ac5080546e92817.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Strategy&lt;/code&gt;的实现通常依赖&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Context&lt;/code&gt;的数据，后者在调用前者的方法时需要将自己传递过去。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;实际应用中，经常会发现不同的策略其算法骨架类似，只有某些具体步骤不同，此时可以对&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Strategy&lt;/code&gt;应用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Template Method&lt;/code&gt;模式。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;7. Template Method 模板方法&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;作用&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;将一个算法的通用骨架抽象到父类以避免代码重复，而将一些可变的步骤延迟到子类，子类不用关心算法结构，只需关注自己需要实现的特定步骤。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1403426928543.png&quot; name=&quot;772bc14e-aeb5-4b1a-a5cc-949ce6f912c0&quot; src=&quot;/assets/img/eb5eef525d7d05d550d5925a2189fa33.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这个没什么好说的。&lt;/p&gt;
&lt;hr style=&quot;-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;&quot;/&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;四. 设计原则&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;单一职责&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;开放-关闭原则&lt;/strong&gt; &lt;br/&gt;
一个类应当对扩展开放，对修改关闭。即当有新的需求时，不是修改已有的类，而是对已有的类进行扩展。 &lt;br/&gt;
实现开闭原则的关键在于 &lt;strong style=&quot;font-weight: bold;&quot;&gt;分离不变和变化的部分，并对变化的部分进行合理的高层抽象，并让不变的部分依赖该高层抽象&lt;/strong&gt;，这样就能在不同的实现间切换，或者扩展新的实现。很多设计模式都体现了这一点，比如&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;策略模式&lt;/code&gt;将算法抽象出来，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;模板方法&lt;/code&gt;将不变的算法骨架与易变的需要自定义的步骤隔离，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;装饰者模式&lt;/code&gt;将不变的核心功能对象和易变的增强功能隔离等等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;里氏替换原则&lt;/strong&gt; &lt;br/&gt;
子类必须能替换掉父类，这个原则通常由语言保证。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;依赖倒置&lt;/strong&gt; &lt;br/&gt;
高层不直接依赖底层，而是高层定义自己需要底层提供什么样的接口，底层负责实现，这样就可以随意切换底层的具体实现而不用影响高层，但底层反而要依赖高层公布的接口，所以称为“依赖倒置”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;接口分离原则 (interface segregation principle)&lt;/strong&gt; &lt;br/&gt;
不应出现庞大的接口，迫使客户在使用时必须从一大堆它不需要的方法中寻找目的方法。这样的接口应该按照不同客户的需求被分离成若干小接口。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;最少知识原则（least knowledge principle）&lt;/strong&gt; &lt;br/&gt;
类应当只与自己的朋友交互。该原则的思想是，将类对外部的了解尽量保持在一定范围内，尽量减少类之间的交互，从而降低各个组件间的耦合。 &lt;br/&gt;
“朋友”的定义：&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;当前对象的属性&lt;/li&gt;
&lt;li&gt;当前对象所创建的对象&lt;/li&gt;
&lt;li&gt;方法参数传递进来的参数&lt;/li&gt;
&lt;li&gt;方法内创建的对象&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>ThreadLocal 分析</title>
      <link>http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html</link>
      <pubDate>11 Sep 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal 分析</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;ThreadLocal 分析&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;典型的使用方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;典型使用场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;从功能上来说，它类似一个全局的Map，key是线程。不同线程get时拿到的都是专属于自己的那个对象，互相隔离，完全不存在并发问题。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;典型的使用方式&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #75715e;&quot;&gt;// 摘自 j.u.c.ThreadLocalRandom&lt;/span&gt;
&lt;span style=&quot;color: #f92672;&quot;&gt;private&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;final&lt;/span&gt; ThreadLocal&amp;lt;ThreadLocalRandom&amp;gt; localRandom =  &lt;span style=&quot;color: #75715e;&quot;&gt;// ThreadLocal对象都是static的，全局共享&lt;/span&gt;
    &lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;ThreadLocalRandom&amp;gt;() {      &lt;span style=&quot;color: #75715e;&quot;&gt;// 初始值&lt;/span&gt;
        &lt;span style=&quot;color: #f92672;&quot;&gt;protected&lt;/span&gt; ThreadLocalRandom initialValue() {
            &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; ThreadLocalRandom();
        }
};

localRandom.&lt;span style=&quot;color: #f92672;&quot;&gt;get&lt;/span&gt;();      &lt;span style=&quot;color: #75715e;&quot;&gt;// 拿当前线程对应的对象&lt;/span&gt;
localRandom.put(...);   &lt;span style=&quot;color: #75715e;&quot;&gt;// put&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;典型使用场景&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;用空间换并发度；&lt;/li&gt;
&lt;li&gt;在线程范围内传参，如 hibernate 的 session；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一个非常自然想法是用一个线程安全的 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Map&amp;lt;Thread,Object&amp;gt;&lt;/code&gt; 实现：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;class ThreadLocal { 
  &lt;span style=&quot;color: #f92672;&quot;&gt;private&lt;/span&gt; Map values = Collections.synchronizedMap(&lt;span style=&quot;color: #f92672;&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;HashMap&lt;/span&gt;());

  &lt;span style=&quot;color: #f92672;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;Object&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;get&lt;/span&gt;() {
    Thread curThread = Thread.currentThread();
    &lt;span style=&quot;color: #f92672;&quot;&gt;Object&lt;/span&gt; o = values.&lt;span style=&quot;color: #e6db74;&quot;&gt;get&lt;/span&gt;(curThread);
    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; (o == &lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !values.containsKey(curThread)) {
      o = initialValue();
      values.put(curThread, o);
    }
    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; o;
  }

  &lt;span style=&quot;color: #f92672;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;set&lt;/span&gt;(&lt;span style=&quot;color: #f92672;&quot;&gt;Object&lt;/span&gt; newValue) {
    values.put(Thread.currentThread(), newValue);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;但这是非常naive的：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;本意是避免并发，用一个全局Map显然违背了这一初衷；&lt;/li&gt;
&lt;li&gt;用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Thread&lt;/code&gt;当key，除非手动调用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;remove&lt;/code&gt;，否则即使线程退出了 1)该&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Thread&lt;/code&gt;对象无法回收； 2)该线程在所有&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;中对应的value也无法回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;JDK 的实现刚好是反过来的： &lt;br/&gt;
&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1404916039768.png&quot; name=&quot;7adc9cbf-24e8-4274-887c-45862c1925c5&quot; src=&quot;/assets/img/3603e633a6095f8aaf63273ed133a2e8.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;每个Thread对象内都存在一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;对象，保存着该线程所有用到的&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;及其value。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocalMap&lt;/code&gt;是定义在&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;类内部的私有类，它是采用“开放定址法”解决冲突的hashmap。key是&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;对象。当调用某个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;对象的&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;get&lt;/code&gt;或&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;put&lt;/code&gt;方法时，首先会从当前线程中取出ThreadLocalMap，然后查找对应的value：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;public&lt;/span&gt; T get() {
    &lt;span style=&quot;color: #f92672;&quot;&gt;Thread&lt;/span&gt; t &lt;span style=&quot;color: #e6db74;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;Thread&lt;/span&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;.&lt;/span&gt;currentThread();
    ThreadLocalMap &lt;span style=&quot;color: #e6db74;&quot;&gt;map&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;=&lt;/span&gt; getMap(t);     &lt;span style=&quot;color: #75715e;&quot;&gt;//拿到当前线程的ThreadLocalMap&lt;/span&gt;
    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #e6db74;&quot;&gt;map&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;!=&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;null&lt;/span&gt;) {
        ThreadLocalMap&lt;span style=&quot;color: #e6db74;&quot;&gt;.&lt;/span&gt;Entry e &lt;span style=&quot;color: #e6db74;&quot;&gt;=&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;map&lt;/span&gt;&lt;span style=&quot;color: #e6db74;&quot;&gt;.&lt;/span&gt;getEntry(this);    &lt;span style=&quot;color: #75715e;&quot;&gt;// 以该ThreadLocal对象为key取value&lt;/span&gt;
        &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; (e &lt;span style=&quot;color: #e6db74;&quot;&gt;!=&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;null&lt;/span&gt;)
            &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; (T)e&lt;span style=&quot;color: #e6db74;&quot;&gt;.&lt;/span&gt;value;
    }
    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; setInitialValue();
}
ThreadLocalMap getMap(&lt;span style=&quot;color: #f92672;&quot;&gt;Thread&lt;/span&gt; t) {
    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; t&lt;span style=&quot;color: #e6db74;&quot;&gt;.&lt;/span&gt;threadLocals;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;现在来看看它的哈希策略。所有&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;对象共享一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;AtomicInteger&lt;/code&gt;对象&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;nextHashCode&lt;/code&gt;用于计算hashcode，一个新对象产生时它的hashcode就确定了，算法是从0开始，以&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;HASH_INCREMENT = 0x61c88647&lt;/code&gt;为间隔递增，这是&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;唯一需要同步的地方。根据hashcode定位桶的算法是将其与数组长度-1进行与操作：&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;key.threadLocalHashCode &amp;amp; (table.length - 1)&lt;/code&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;0x61c88647&lt;/code&gt;这个魔数是怎么确定的呢？&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocalMap&lt;/code&gt;的初始长度为16，每次扩容都增长为原来的2倍，即它的长度始终是2的n次方，上述算法中使用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;0x61c88647&lt;/code&gt;可以让hash的结果在2的n次方内尽可能均匀分布，减少冲突的概率。具体原因我也不知道，不过这是一个好的参考。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;内存管理&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocalMap.Entry&lt;/code&gt;继承自&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;WeakReference&lt;/code&gt;，是 key（ThreadLocal 对象） 和 value 的容器：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;static &lt;span&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color: #f8f8f2;&quot;&gt;Entry&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;extends&lt;/span&gt;&lt;/span&gt; &lt;span style=&quot;color: #a6e22e; font-style: italic;&quot;&gt;WeakReference&amp;lt;ThreadLocal&amp;gt;&lt;/span&gt; {&lt;/span&gt;
    &lt;span style=&quot;color: #75715e;&quot;&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;
    &lt;span&gt;Object&lt;/span&gt; value;

    &lt;span&gt;Entry&lt;/span&gt;(&lt;span&gt;ThreadLocal&lt;/span&gt; k, &lt;span&gt;Object&lt;/span&gt; v) {
        &lt;span style=&quot;color: #f92672;&quot;&gt;super&lt;/span&gt;(k);
        value = v;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一旦某个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;对象没有强引用了，它在所有线程内部的&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocalMap&lt;/code&gt;中的key都将被GC掉（此时value还未回收），在map后续的&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;get/set&lt;/code&gt;中会探测到key被回收的entry，将其 value 设置为 null 以帮助GC，因此 value 在 key 被 GC 后可能还会存活一段时间，但最终也会被回收。这个过程和&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;java.util.WeakHashMap&lt;/code&gt;的实现几乎是一样的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因此&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt;本身是没有内存泄露问题的，通常由它引发的内存泄露问题都是由于线程只 put 而忘了 remove ，从上面分析可知，即使线程退出了，只要 &lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;ThreadLocal&lt;/code&gt; 还有强引用，该线程曾经 put 过的东西是不会被回收掉的。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>MapReduce Algorithms</title>
      <link>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html</link>
      <pubDate>04 Sep 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce Algorithms</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;MapReduce Algorithms&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. MapReduce 工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. 常见算法的 MapReduce 实现&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.1 count / distinct&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;distinct&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.2 group by / aggregation&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.3 inverted index&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.4 sort&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.5 median / 第 k 大数&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.6 top k&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.6.1 出现次数 top k 的元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2.7 join&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;解决&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Replicated Join (Map Join, Hash Join)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Repartition Join (Reduce Join, Sort-Merge Join)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;join 优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. 参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;1. MapReduce 工作原理&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一图胜千言：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409802041299.png&quot; name=&quot;1a6b1e79-166a-4285-84f2-0128d87d409f&quot; src=&quot;/assets/img/3b6dc283d85bb557aa3ad7b9974069fd.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Mapper&lt;/strong&gt;:&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Mapper 主要做些信息抽取、过滤等工作&lt;/li&gt;
&lt;li&gt;Mapper 数量由输入的 split 数决定，hadoop 会尽量选择靠近数据的节点运行 mapper 任务，因此可以认为 mapper 是 data-local 的&lt;/li&gt;
&lt;li&gt;生成的 &lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;2. 常见算法的 MapReduce 实现&lt;/h2&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.1 count / distinct&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题描述&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;其实就是 Hadoop wordcount 的例子：一堆文档，每个文档内一堆单词，统计每个单词出现次数。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Mapper：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;raw data    --&amp;gt;    对每个碰到的单词，输出 &amp;lt;word,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Shuffle 后可以保证同一个单词的所有键值对被一个 Reducer 处理&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Reducer：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&amp;lt;word,[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1.&lt;/span&gt;..]&amp;gt;   --(sum)--&amp;gt;    &amp;lt;word,&lt;span style=&quot;color: #ae81ff;&quot;&gt;5&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;优化&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;用 combiner 合并 mapper 的输出，减少传输数据量： &lt;br/&gt;
Mapper：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;raw data 
&lt;span style=&quot;color: #ae81ff;&quot;&gt;1.&lt;/span&gt; --(mapper)--&amp;gt;    &amp;lt;word1,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;&amp;gt; &amp;lt;word1,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;&amp;gt; &amp;lt;word2,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;&amp;gt; 
&lt;span style=&quot;color: #ae81ff;&quot;&gt;2.&lt;/span&gt; --(combine)--&amp;gt;   &amp;lt;word1,&lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt;&amp;gt; &amp;lt;word2,&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;distinct&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;distinct 就是集合去重，解决思路和 count 问题一样，不过不需要记录单词出现次数，键值对的 value 用 null 就可以了：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;Mapper:
raw data    --&amp;gt;    &amp;lt;word,&lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;&amp;gt;

Reducer:
&amp;lt;word,[&lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;,&lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;...]&amp;gt;   --&amp;gt;    &amp;lt;word,&lt;span style=&quot;color: #f92672;&quot;&gt;null&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.2 group by / aggregation&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;实现类似数据库的 group by 及聚合函数的功能&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;实现&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Mapreduce 的 shuffle 过程其实已经帮我们做了 group by 的工作，Reducer 拿到的输入就是 group by 后的结果，对其 value 应用聚合函数即可。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.3 inverted index&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一堆文档，构造对应的倒排索引。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思路和 wordcount 是一样的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Mapper：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;对一个文档中的每个单词，输出 &amp;lt;word,fileName&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;优化：可以用 Combiner 合并 Mapper 的输出。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Reducer:&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;Rducuer 的输入是 &amp;lt;word,[file1,file2...]&amp;gt;，直接输出就好了&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.4 sort&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一堆文件，每个文件都有若干行，一行是一个数字，数字的范围是确定的，要求对其排序。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;利用 Reducer 拿到的输入是有序的这一特性，Mapper 和 Recuder 如果都用 identity function，那么每个 Reducer 的输出都是有序的，但 Reducer 之间无法保证有序。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果用归并排序的思路， 那么最后还需要一个只有一个 Reducer 的 Mapreduce 任务对所有数据做一次 merge，这显然是无法接受的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;真正可行的算法是 &lt;strong style=&quot;font-weight: bold;&quot;&gt;桶排序&lt;/strong&gt;。回顾桶排序的过程，它首先将数据分布范围划分为若干个桶，接着遍历一遍元素并分配到对应的桶中，然后对每个桶做一次排序，因为桶之间是有序的，所以不需要 merge。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在 Mapreduce 中，Partitioner 负责划分桶。举个例子，假设数据分布在 1 到 1w 之间，我们可以将其划分为 10 个桶，同时用 10 个 Reducer 处理每个桶内的数据，这样 Reducer 间就是有序的。为了实现这个效果，可以用一个自定义的Partitioner，将 Mapper 输出划分到上述 10 个桶内即可。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.5 median / 第 k 大数&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一堆数字，找中位数或第 k 大数。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;工作中遇见过一个类似的问题，场景是：&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;有一堆 Nginx 登陆日志，每条 log 都有一个时间点，要求找到一个时间点，使得该时间点之前的日志数占总日志数的 30%。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在小数据量场景下，反复利用快速排序的分割可以在 O(n) 范围内找到第 K 大数。我们可以将这个思路扩展到分布式环境下：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;用一个 MapReduce 任务统计所有日志的时间范围和日志总数；&lt;/li&gt;
&lt;li&gt;随机选一个时间点，用一个新的任务统计该时间点之前和之后的日志数；&lt;/li&gt;
&lt;li&gt;如果该时间点不满足要求，则根据 2 的结果找一个新的时间点，重复步骤2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;通常这类统计需求不要求非常精确，得到一个差不多的值就可以了。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.6 top k&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;求一堆数前 k 大的数。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;其实这个问题和上面的第 k 大数是一样的，可以用上面的思路解决，这里介绍一种 k 比较小时效率更高的算法。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果数据量很小，求 top k 可以用一个小根堆维护 top k，堆顶为这最大的 k 个数中的最小元素，把所有数据过一遍，最后堆内就是所求值了。这个算法可以很容易地扩展到分布式的环境中：先求出每个 split 的 top k，合并这些元素再求一次 top k 即得结果。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Mapper：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;维护一个小根堆，任务结束后对堆内每个元素输出一个键值对 &amp;lt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&lt;/span&gt;,num1&amp;gt;, &amp;lt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&lt;/span&gt;,num2&amp;gt; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Reducer（数量为 1）：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;得到的输入为 &amp;lt;&lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&lt;/span&gt;,[每个 split 的 top k]&amp;gt;，对 value 求一次 top k 就可以了。&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法的优势在于只要一次 Mapreduce 任务即可，但缺点是只适用于 k 比较小的情况，如果 k 很大：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;如果 k 大于每个 split 内包含的记录数，算法失效；&lt;/li&gt;
&lt;li&gt;Reducer 可能没有足够的内存容纳输入&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.6.1 出现次数 top k 的元素&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;比上面的 top k 问题多了一个步骤，&lt;strong style=&quot;font-weight: bold;&quot;&gt;要求出每个元素的出现次数&lt;/strong&gt;。如果数据量比较小，可以用下面方法：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;bitmap（如果不是数字的话则用 hashmap）+ 堆 / 快排的分割&lt;/strong&gt; &lt;br/&gt;
bitmap / hashmap 用来统计元素的出现次数，堆用来保存当前 top k，只需一次遍历即可。    用快排的分割的话，要先统计出次数再分割，不只一次遍历。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;不要求精确的话，可以用 &lt;strong style=&quot;font-weight: bold;&quot;&gt;计数版本的 BloomFilter + 堆&lt;/strong&gt; &lt;br/&gt;
BloomFilter 只保存了元素的次数，没有保存元素，因此只能边统计边记录 top k，一次遍历。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果是大数据量就需要&lt;strong style=&quot;font-weight: bold;&quot;&gt;先用一个 hadoop 任务来分割&lt;/strong&gt;，保证同一个元素的记录被分配到同一个 reducer，这样可以求出每个元素的出现次数；以这个任务的输出为输入，用上面提到的 top k 算法求出每个 split 的 top k；最后用一个 reducer 进行 merge，求出 top k 的 top k。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;2.7 join&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;join！&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;解决&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;通常有以下两种算法：&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;Replicated Join (Map Join, Hash Join)&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果 join 的一方数据量较小，可以载入内存，则可以用 Hadoop 的 Distributed Cache 将其分发到每个 Mapper 节点，在 Mapper 端进行 join。较小数据集在 Mapper 端通常被构造成一个 HashMap 以加速查找，因此 Mapper Join 实质上是一种 Hash join。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h5 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1em; margin: 1.2em 0; text-align: start;&quot;&gt;Repartition Join (Reduce Join, Sort-Merge Join)&lt;/h5&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果两个数据集都很大，可在 Reducer 侧做 join：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Mapper 同时处理两个集合的数据，为遇到的每个记录生成一个键值对，key 是 join 的列值，value 除了该记录还需要一个 tag 表明它来自哪个集合:&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;raw data    --&amp;gt;    &amp;lt;key,(record,fromA)&amp;gt;, &amp;lt;key,(record,fromB)&amp;gt; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Shuffle 后 Reducer 得到一个 key 对应的所有记录，无论是来自集合 A 还是 B。接下来 Reducer 用循环，根据 join 的类型对这些记录做连接即可。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法的关键在于 shuffle 阶段的排序，因此本质上是一种 Sort-Merge join。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Reducer 侧 join 是一种通用的 join 算法，但它有以下缺点：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Mapper 侧根本不过滤数据，所有数据，即使是那些无法 join 的记录，都会被传输到 Reducer 侧，再由 Reducer 过滤，这样性能很差；&lt;/li&gt;
&lt;li&gt;Reducer 侧可能没有足够的内存装下一个 key 对应的所有记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;join 优化&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;考虑这样一个场景：有两个数据集，Customer 和 Order，要求对他们进行 join，但仅限于地区在上海的顾客。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;有几种可能的优化方式：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;预先过滤一个集合，使用 Replicated Join&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;利用“地区为上海”这个约束过滤 Customer，如果过滤后的数据集足够小，则可以采用 Replicated Join；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;用半连接(semi join)优化 Reduce Join：先过滤集合 A ，再用得到的结果在 Mapper 处过滤集合 B，最后在 Reducer 处 Join&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果过滤后的数据集依然很大，那么只能采用低效率的 Reduce join。优化 Reduce join 的主要策略是 &lt;strong style=&quot;font-weight: bold;&quot;&gt;尽量将数据过滤动作放在 Mapper 进行&lt;/strong&gt;（这也是一个通用准则），在上述例子中， Mapper 在处理某个 Order 时，如果知道其对应的 Customer 不在 Customer 集合中，或者不在上海地区，那么就可以跳过它而不用传输到 Reducer 侧。为了达到这一点，我们可以先对 Customer 过滤（就像1一样），将上海的顾客的&lt;em&gt;* ID *&lt;/em&gt;选出来，这样得到的文件比1得到的文件更小（因为它只有一个 ID），很有可能可以被装入内存。用 Distributed Cache 将该 ID 文件分发到所有 Mapper 节点，Mapper 在处理 Customer 或 Order 的记录时就可以根据这个集合过滤所有非上海的顾客了。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;如果过滤得到的 ID 文件依然很大，这时判重利器 &lt;a href=&quot;http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;BloomFilter&lt;/strong&gt;&lt;/a&gt; 就派上用场了。我们可以建立一个 BloomFilter 表示过滤后的顾客 ID 集合，它的尺寸要远小于原始集合。BloomFilter 存在的误判率也不是问题，它只会把不存在的元素误判为存在，Reducer 处也会进行过滤，可以把误判的元素剔除掉。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;基于 Mapreduce 为超大集合建立 BloomFilter 的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;每个 Mapper 对自己负责的 split 建立 BloomFilter，用一个 Reducer 接收它们并两两相“或”，即得到整体集合的 BloomFilter。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;这利用了 BloomFilter 的性质：&lt;/p&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;filter1 | filter2 == 并集
filter1 &amp;amp; filter2 == 交集&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;3. 参考&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;a href=&quot;http://highlyscalable.wordpress.com/2012/02/01/mapreduce-patterns/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Mapreduce patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.cloudera.com/wp-content/uploads/2010/01/5-MapReduceAlgorithms.pdf&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Mapreduce algorithms.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Hadoop in action》&lt;/li&gt;
&lt;li&gt;《Hadoop 权威指南》&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>高性能网络通讯笔记</title>
      <link>http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html</link>
      <pubDate>03 Sep 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/09/03/高性能网络通讯笔记</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;高性能网络通讯笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;传统rpc的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;数据协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;IO模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;线程模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;前几天看了下阿里巴巴 RPC 框架 Dubbo 作者的内部分享，这里记下笔记。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h1 style=&quot;font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;&quot;&gt;传统rpc的问题&lt;/h1&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;java序列化，性能低&lt;/li&gt;
&lt;li&gt;每连接每线程，BIO有性能问题&lt;/li&gt;
&lt;li&gt;jdk代理性能低&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;
&lt;h1 style=&quot;font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;&quot;&gt;数据协议&lt;/h1&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;应用层协议&lt;/li&gt;
&lt;li&gt;header字段： &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;magic high&lt;/li&gt;
&lt;li&gt;magic low  — 端口复用，多协议支持；兼容其他协议。&lt;/li&gt;
&lt;li&gt;序列化方式&lt;/li&gt;
&lt;li&gt;event&lt;/li&gt;
&lt;li&gt;是否双向&lt;/li&gt;
&lt;li&gt;请求还是响应&lt;/li&gt;
&lt;li&gt;status&lt;/li&gt;
&lt;li&gt;id  – futureMap保存所有发送的请求，响应中携带请求id，实现一一对应 &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;使用int id替换long，实现id轮转+超时（？？）&lt;/li&gt;
&lt;li&gt;剩下来的位数可以用来扩展，存储服务器状态&lt;/li&gt;
&lt;li&gt;使用future机制把客户端的同步调用转成异步的&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;data length&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;序列化协议 &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;web应用cpu负载低，网络负载高。数据包大小比压缩时间更重要。网络传输的时间远远大于cpu压缩时间，过于追求低压缩时间没有意义。&lt;/li&gt;
&lt;li&gt;发送前压缩数据包。&lt;/li&gt;
&lt;li&gt;另一个考虑的因素：工具使用的方便程度、适用场景是否广泛。protobuf用起来麻烦、hession/fastjson有些情况会序列化失败、java serialize最安全和普适。如果这里不是一个明显的瓶颈，可以直接使用java内置的序列化方式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;序列化策略 &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;chunk stream&lt;/li&gt;
&lt;li&gt;一个连接上承载多个请求发送。如果一个请求过大发送时间过长会造成其他请求不能及时得到处理，容易出现超时。— 将这些大的数据包拆分成多片，穿插发送。server端自己拼装。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;
&lt;h1 style=&quot;font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;&quot;&gt;IO模型&lt;/h1&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Unix的5种IO模型&lt;/li&gt;
&lt;li&gt;IO的两个阶段&lt;/li&gt;
&lt;li&gt;是否阻塞 – 异步、同步&lt;/li&gt;
&lt;li&gt;Blocking IO、Non-Blocking IO（non-blocking的意义：当需要睡眠当前线程时才能完成请求时，不睡眠，只做部分操作并返回；从内核拷贝数据到用户空间时依然会阻塞）、IO multiplexing（事件驱动，一般和non blocking IO搭配使用）、Signal-Driven IO&lt;/li&gt;
&lt;li&gt;Asynchronous IO&lt;/li&gt;
&lt;li&gt;NIO的优势 &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;避免多线程&lt;/li&gt;
&lt;li&gt;基于block的传输比基于流的传输更高效&lt;/li&gt;
&lt;li&gt;基于mmap的zero-copy&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TCP的调优 &lt;br/&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;正确设置socket缓冲区，接收/发送缓冲区大小应该至少 = Bandwidth Delay Product = 带宽 * 往返时间，这样才能把两端之间的通信链路填满数据，充分利用带宽。 &lt;br/&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;减少进程读写缓冲区的系统调用；&lt;/li&gt;
&lt;li&gt;充分利用带宽&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;关闭nagle算法，RPC 调用不允许延迟&lt;/li&gt;
&lt;li&gt;在应用层做心跳检测，关闭tcp的keep-alive（这是全局设置）&lt;/li&gt;
&lt;li&gt;网卡中断负载均衡&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h1 style=&quot;font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;&quot;&gt;线程模型&lt;/h1&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;MainReactor * 1负责接受连接 + SubReactor * N (thread pool，“IO线程”, 负责监听读写事件. 一个线程负责多个连接)的方式，和Netty一样。&lt;/li&gt;
&lt;li&gt;业务处理时也引入线程池&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;codec（数据收集/拼装）/serialize（序列化/反序列化）在什么线程里做&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;Netty中codec直接在IO线程中做，dubbo也一样；&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Serialize/deserialize 分开了，在业务线程（池）中做； &lt;br/&gt;
原因原文没说，猜测：&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;serialize是比较耗时的，所有耗时的操作都应该放在业务线程中做，IO线程必须快速返回以便处理下一个连接，否则容易造成后续连接过很久才能得到处理，易超时；&lt;/li&gt;
&lt;li&gt;codec为什么不放在业务线程中做？一是职责分离，业务线程的输入是有意义的完整数据包；二是在数据包不完整时，业务线程基本上会快速退出继续阻塞，这会导致业务线程池的不稳定和频繁的线程切换。&lt;/li&gt;&lt;/ul&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;任务的合理切分。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;在NIO的客户端，接受数据的事件将会写得很轻量级，但是接受到数据然后分析数据还原成业务对象，之后则会通过线程池的方式来分别处理。就好比监听连接到来，和实际的去建立连接分成了两个阶段的任务，让事件型的任务单纯，快速执行，让与业务相关的部分通过多线程并行的方式提高处理效率。总的来说就是把任务划分成为 &lt;strong style=&quot;font-weight: bold;&quot;&gt;系统性的任务&lt;/strong&gt; 和 &lt;strong style=&quot;font-weight: bold;&quot;&gt;业务性的任务&lt;/strong&gt;，前者消耗时间少，设计尽量简单高效，采用单线程处理即可，后者通常情况下在处理流程和资源上不冲突的情况可以通过多线程并行提高效率。（后者IO bound时多线程可以提高效率[依赖]，CPU bound时均分计算资源，要慢一起慢，不会出现一个任务耗时导致别的任务超时，此时处理总时间由于线程切换的开销反而会更大）&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;— 放翁 《优化杂谈》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;多线程的目的: 1. 阻塞时可以利用CPU;  2. 均分计算资源, 让多个任务都得以推进&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;业务线程池应该多大？ &lt;br/&gt;
这一部分来自淘宝的《前台系统性能调优》&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;根据业务的CPU/IO类型不同，充分利用IO阻塞与CPU执行的overlapping（交错执行）&lt;/li&gt;
&lt;li&gt;公式 — 从CPU角度：&lt;/li&gt;&lt;/ul&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;50.75&quot; longdesc=&quot;__SVG__e04b5f594afd4ffe12b30403d1037c41&quot; name=&quot;71b3d9e9-98d2-4c60-8f6a-296830144545&quot; src=&quot;/assets/img/76e68b55e19152a546c83e36f045453f&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;324.625&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;鸵鸟策略：设置多线程数，保证能充分利用CPU；线程切换开销假装没有，的确是瓶颈时再调。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Skyline监控系统工作原理分析</title>
      <link>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</link>
      <pubDate>03 Sep 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline监控系统工作原理分析</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Skyline监控系统工作原理分析&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Horizon&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Listener&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;TCP pickle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;UDP messagepack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Worker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Roomba&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Analyzer&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Analyzer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Webapp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;概述&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Skyline是一个实时的异常监测系统，它被动地接收metrics数据，并使用一系列算法自动地判断metrics是否异常，此外，用户可以很容易地根据自己应用数据的特点，提供自己的异常检测算法。Skyline还提供了一个web Ui接口，异常的metrics会在webapp中得到展示。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Skyline内部由3个组件组成：Horizon/Analyzer/Webapp：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409638905577.png&quot; name=&quot;d7f1c2c1-b7c6-49c8-bca0-0bc1499c7f0b&quot; src=&quot;/assets/img/7ef2b048d05333ff5ca6e5cf5be92dc9.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;它们的工作方式如下：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Horizon负责接收外部发送过来的datapoint并转发到Redis，同时从Redis中删除过时的datapoint（所谓datapoint是指某个metric在一个特定时间点的数据，它包含timestamp和value）。Analyzer从Redis获取metrics数据，并使用算法判断是否异常。最后Webapp以图表的方式向用户展示异常的metrics。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Horizon和Analyzer的工作流程如下图所示，红色字体标注的是settings.py中定义的配置项：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409638939192.png&quot; name=&quot;b55f09cd-526f-45c2-8ffd-497ff6cfa837&quot; src=&quot;/assets/img/d3f0fc8692ffd01d09d7f7b12d6f4b90.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;Horizon&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Horizon是Skyline的数据收集器，它由3个角色组成：Listener/Worker/Roomba。Horizon通过bin/horizon.d启停。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409638965027.png&quot; name=&quot;270f4d0c-9f18-4e2d-8b41-51164796a5a1&quot; src=&quot;/assets/img/8e250921c3dbeee4f233ca21e6991fdc.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Listener&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Listener负责接收外部发送过来的数据，每个Listener是一个进程，目前会启动两种类型的Listener：TCP和UDP，它们使用的应用层协议不同，且数据的序列化方式也不同。应用向horizon发送metric数据时是以tuple为单位的，一个tuple的格式如下所示，表示某个metric在某个时刻的值：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;tuple == &lt;span style=&quot;color: #75715e;&quot;&gt;(metric_name, datapoint)&lt;/span&gt; == &lt;span style=&quot;color: #75715e;&quot;&gt;(metric_name, [timestamp,value])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;TCP pickle&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;TCP类型的Listener使用的序列化方式是cPickle，应用层协议如下：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;+----------------------------+-------------------------------------------------------------------------------+
| length(&lt;span style=&quot;color: #ae81ff;&quot;&gt;4&lt;/span&gt; bytes)            | [ [tuple1,tuple2...(of metric &lt;span style=&quot;color: #e6db74;&quot;&gt;&#39;A&#39;&lt;/span&gt;)], [tuple1,tuple2...(of metric &lt;span style=&quot;color: #e6db74;&quot;&gt;&#39;B&#39;&lt;/span&gt;)], &lt;span style=&quot;color: #f92672;&quot;&gt;...&lt;/span&gt;]  |
+----------------------------+-------------------------------------------------------------------------------+&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;前4个字节是length，表示后续数据的长度。接下来是一个使用cPickle序列化的数组，tuple根据metric name分组，每组是该数组内的一个元素。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;UDP messagepack&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;UDP类型的Listener使用的序列化方式是msgpack，应用层协议为：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #a6e22e;&quot;&gt;+---------+&lt;/span&gt;
&lt;span style=&quot;color: #f92672;&quot;&gt;|  tuple  |
+---------+&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;是的，很简单，把tuple用msgpack序列化后发送即可。因为UDP可以保持消息边界的特性，因此不需要length字段。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Listener接收datapoint后将其缓存在内部的Chunk队列中，其长度由CHUNK_SIZE决定；Chunk满后被放入一个公共的队列Queue中，该队列的长度为MAX_QUEUE_SIZE。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Worker&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Worker负责处理公共队列Queue中的Chunk，Horizon在启动时会创建WORKER_PROCESSES个worker进程，不停地从Queue中出队Chunk，将Chunk内的datapoint经msgpack序列化后，按其所属的metric添加到对应的Redis队列中。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Skyline在Redis中定义了两个namespace：FULL_NAMESPACE和MINI_NAMESPACE，MINI的作用稍微次要一点，我们先忽略它，后面提及Roomba时再讲解。两个namespace下的结构都是一致的：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;FULL_NAMESPACE + ${metric name} ==&amp;gt; List [ datapoint1,datapoint2,datapoint3 … ] (&lt;strong style=&quot;font-weight: bold;&quot;&gt;timeseries&lt;/strong&gt;)&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;每个metric都有一个List保存着它所对应的datapoint集合，这个List在Skyline中又被称为timeseries，它保存着该metric在一段时间内的取值序列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;FULL_NAMESPACE + ‘unique_metrics’  ==&amp;gt; Set [metric name 1,  metric name 2, … ] &lt;br/&gt;
该Set保存着所有metric的名字以便快速查找。 &lt;br/&gt;
Worker根据Chunk内tuple所携带的metric name信息，将datapoint发送到Redis的两个namespace中以供Analyzer模块分析。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Roomba&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Roomba负责清除Redis各timeseries中过时的datapoint，只留下最近某段时间内的datapoint，保证Redis不爆掉。Horizon启动时会启动Roomba线程（Roomba和Worker不太一样，它是继承Thread的，虽然它的实际工作都是靠创建的进程完成的），对FULL和MINI两个namespace分别创建ROOMBA_PROCESSES个进程，从FULL/MINI_NAMESPACE + ‘unique_metrics’ 中找到所有的metrics并均匀地分配给每个进程处理。后者对每个分配的timeseries，删除距当前FULL/MINI_DURATION + ROOMBA_GRACE_TIME秒前的datapoint；如果整个timeseries都过时了，则该metric的List会从Redis中删除，同时metric name也会从set中删除。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;所有进程都退出后，Roomba线程继续循环，即将进行下一轮进程的创建。为了防止Redis中数据很少时，进程快速的创建和退出带来的性能消耗，每个进程在退出时都会判断运行的时间，如果小于30s，则休眠10s。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因此，Roomba的工作其实就是保证Redis两个namespace下各个timeseries始终是“最近的”一段数据，其时间跨度由FULL_DURATION/MINI_DURATION（以及ROOMBA_GRACE_TIME）指定。FULL命名空间下的timeseries是Analyzer分析的对象，MINI下的并不会被分析，它的作用只在于在web UI中为用户提供某个metric最近一个小时间段（MINI_DURATION）内的概览。此外，MINI namespace还用于和Oculus配合工作，Oculus是Esty公司出品的另一个系统，我们这里忽略掉。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;Analyzer&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409639087710.png&quot; name=&quot;fb060ac0-5f65-42dc-8899-2d05bb7bdedf&quot; src=&quot;/assets/img/d0530f215b0ef90ab0087ffd5f72931f.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;经过Horizon的处理，Redis中已经保存了若干timeseries，Analyzer负责对其进行分析，同时提供了一系列算法判断timeseries是否异常的（anomalous）。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Analyzer&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Analyzer也是一个线程，它的工作方式和Roomba几乎一致，启动后创建ANALYZER_PROCESSES个进程，平均分配FULL_NAMESPACE下的所有timeseries，每个timeseries被送入Algorithms模块处理，判断是否异常并返回异常的datapoint、报告异常的算法。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;所有进程分析完毕后，Analyzer将异常metrics的相关信息dump到webapp的anomalies.json文件中，随后webapp将会通过JSONP请求该文件，得到异常信息并展示。此外，Analyzer还将根据配置的Email信息发送预警邮件。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;最后，Analyzer线程判断整个分析过程耗时，如果&amp;lt;5s，则休眠10s，醒后重新进入下一轮进程创建。这里和Roomba有点差别，Roomba的休眠由各个进程判断，而这里是由Analyzer线程进行。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;Algorithms&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这里是判断异常的核心所在，Skyline内置了9个算法来判断一个datapoint序列是否异常，用户可以根据自己应用的特征配置要使用的算法（ALGORITHMS配置项），或者自定义自己的判定算法。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;run_selected_algorithm(timeseries)方法中，timeseries首先会经过一系列合法性验证：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;datapoint数目太少（&amp;lt; MIN_TOLERABLE_LENGTH）：TooShort异常&lt;/li&gt;
&lt;li&gt;过时（最后一个datapoint在 STALE_PERIOD 秒前）：Stable异常&lt;/li&gt;
&lt;li&gt;时间跨度太短（两端datapoint时间之差 &amp;lt; FULL_DURATION）：Incomplete异常&lt;/li&gt;
&lt;li&gt;重复数据太多（最后MAX_TOLERABLE_BOREDOM个datapoint都是一个值）：Boring异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;验证后将timeseries送入所选算法中进行异常判断。每个算法都会返回Boolean值，true表示异常，false表示正常。当有&amp;gt;CONSENSUS个算法判断为异常时，该timeseries才会被认为是anomalous的。最终返回3个值：是否异常 | 判定为异常的算法集合 | 异常datapoint，异常datapoint目前统一为序列最后3个datapoint的平均值，这和判断异常的算法是相关的，关于Skyline内置的9个算法的分析参见这里。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;Webapp&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Webapp基于Flask框架提供异常metrics的图表展现，是一个比较简单的模块，就不展开了。基本原理是向后台轮询anomalies.json，得到异常的metrics名称及对应的异常datapoint，之后根据metrics name向后台请求Redis中的timeseries序列（包括FULL/MINI namespace），并用图表展示出来。借用官网的一张图：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409639146495.png&quot; name=&quot;ab5b5a19-7738-4d52-b489-7b27c5bdea45&quot; src=&quot;/assets/img/f45b6095218bcc1ffd34bc662c7d0404.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;需要一提的是，图中所示1 hour和24 hour下的图表，分别是从MINI和FULL NAMESPACE中取得的timeseries数据，它们的时间跨度分别由参数MINI_DURATION和FULL_DURATION决定，并非固定的1小时或24小时，只不过页面上是这么写死的。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;问题&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Roomba对同一timeseries两次trim的时间间隔在10s以上，Analyzer是5s以上，如果FULL_DURATION过短（比如几秒），则两次analysis之间的Roomba过程可能将第一次分析后加入的新datapoint删除，当两次analysis的间隔 &amp;gt; FULL_DURATION时就有可能会发生这种情况。因此使用Skyline时不能将分析的单位时间跨度FULL_DURATION设置的过短；同时选择的算法不宜过多太复杂，否则一次analysis的耗时比FULLL_DURATION还高，就有可能出现上述问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;现在大部分的异常判定算法都是取timeseries的最后3个datapoint和整体序列进行比较，如果某些metrics的发送频率较快，在两次analysis的间隔（不考虑算法的运行时间的话5s-15s）内发送了多于3个的datapoint，这样，在第二次analysis时，就会忽略掉N-3个数据，假如异常刚好发生在倒数第4个datapoint处，则检测不到。因此metrics发送的频率（resolution）也不宜过高。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;我在Skyline的group里向作者提到了这两个疑问，&lt;a href=&quot;https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fgroups.google.com%2Fforum%2F%23%21topic%2Fskyline-dev%2FZMvrdh6UX4M&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;作者的回答&lt;/a&gt;是：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;第一种情况不太可能出现，因为实际中Analyzer的耗时大概在一两分钟，远低于通常设置的FULL_DURATION；&lt;/li&gt;
&lt;li&gt;的确会有这样的情况，Analyzer需要重写以便分析这段时间内所有加入的datapoint，而不仅仅是最后3个。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;总结&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;本文大致分析了Skyline的各个角色和工作原理，总的来说，Skyline是一个简单精巧的监控工具，但从代码来看有些地方的处理方式不太一致，在调试的过程中发现了一个比较明显的bug（不过作者的反应很快），给人的感觉不太严谨；其他的问题还有待于实际应用中发现。最后，Skyline的规模对Python的初学者是个很好的源码阅读教材～&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Skyline timeseries异常判定算法</title>
      <link>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html</link>
      <pubDate>03 Sep 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline timeseries异常判定算法</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Skyline timeseries异常判定算法&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3-sigma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;stddev_from_average&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;first_hour_average&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;stddev_from_moving_average&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;关于 Moving Average&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Simple Moving Average&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;Exponential moving average&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;mean_subtraction_cumulation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;least_squares&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;grubbs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;histogram_bins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;ks_test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;median_absolute_deviation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Skyline内部提供了9个预定义的算法，这些算法要解决这样一个问题：&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;input：一个timeseries &lt;br/&gt;
  output：是否异常&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;3-sigma&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;一个很直接的异常判定思路是，拿最新3个datapoint的平均值（tail_avg方法）和整个序列比较，看是否偏离总体平均水平太多。怎样算“太多”呢，因为standard deviation表示集合中元素到mean的平均偏移距离，因此最简单就是和它进行比较。这里涉及到3-sigma理论：&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;In statistics, the 68–95–99.7 rule, also known as the three-sigma rule or empirical rule, states that nearly all values lie within 3 standard deviations of the mean in a normal distribution.&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;About 68.27% of the values lie within 1 standard deviation of the mean. Similarly, about 95.45% of the values lie within 2 standard deviations of the mean. Nearly all (99.73%) of the values lie within 3 standard deviations of the mean.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409640582929.png&quot; name=&quot;3ce62d68-9a4d-4626-9c82-0d6345a5fd46&quot; src=&quot;/assets/img/14112089f9338deb39688c3e27bfddc1.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;简单来说就是：在normal distribution（正态分布）中，99.73%的数据都在偏离mean 3个σ (standard deviation 标准差) 的范围内。如果某些datapoint到mean的距离超过这个范围，则认为是异常的。Skyline初始内置的7个算法几乎都是基于该理论的：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;stddev_from_average&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;stddev_from_average&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the absolute value of the average of the latest
    three datapoint minus the moving average is greater than one standard
    deviation of the average. This does not exponentially weight the MA and so
    is better for detecting anomalies with respect to the entire series.
    &quot;&quot;&quot;&lt;/span&gt;
    series = pandas.Series([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    mean = series.mean()
    stdDev = series.std()
    t = tail_avg(timeseries)

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; abs(t - mean) &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt; * stdDev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法如下：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;求timeseries的mean&lt;/li&gt;
&lt;li&gt;求timeseries的standard deviation&lt;/li&gt;
&lt;li&gt;求tail_avg到mean的距离，大于3倍的标准差则异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法的特点是可以有效屏蔽 “在一个点上突变到很大的异常值但在下一个点回落到正常水平” 的情况，即屏蔽单点毛刺：因为它使用的是末3个点的均值（有效缓和突变），和整个序列比较（均值可能被异常值拉大），导致判断正常。对于需要忽略 “毛刺” 数据的场景而言，该算法比后续的EWMA/mean_subtraction_cumulation等算法更适用（当然也可以改造这些算法，用tail_avg代替last datapoint）。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;first_hour_average&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;first_hour_average&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    Calcuate the simple average over one hour, FULL_DURATION seconds ago.
    A timeseries is anomalous if the average of the last three datapoints
    are outside of three standard deviations of this value.
    &quot;&quot;&quot;&lt;/span&gt;
    last_hour_threshold = time() - (FULL_DURATION - &lt;span style=&quot;color: #ae81ff;&quot;&gt;3600&lt;/span&gt;)
    series = pandas.Series([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;] &amp;lt; last_hour_threshold])
    mean = (series).mean()
    stdDev = (series).std()
    t = tail_avg(timeseries)

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; abs(t - mean) &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt; * stdDev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;和上述算法几乎一致，但是不同的是，比对的对象是 最近FULL_DURATION时间段内开始的1小时内 的数据，求出这段datapoint的mean和standard deviation后再用tail_avg进行比较。当FULL_DURATION小于1小时(86400)时，该算法和上一个算法一致。对于那些在一段较长时间内匀速递增/减的metrics，该算法可能会误报。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;stddev_from_moving_average&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;stddev_from_moving_average&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the absolute value of the average of the latest
    three datapoint minus the moving average is greater than one standard
    deviation of the moving average. This is better for finding anomalies with
    respect to the short term trends.
    &quot;&quot;&quot;&lt;/span&gt;
    series = pandas.Series([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    expAverage = pandas.stats.moments.ewma(series, com=&lt;span style=&quot;color: #ae81ff;&quot;&gt;50&lt;/span&gt;)
    stdDev = pandas.stats.moments.ewmstd(series, com=&lt;span style=&quot;color: #ae81ff;&quot;&gt;50&lt;/span&gt;)

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; abs(series.iget(-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;) - expAverage.iget(-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;)) &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt; * stdDev.iget(-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法先求出最后一个datapoint处的EWMA（Exponentially-weighted moving average）mean/std deviation，然后用最后 3 个datapoint的平均值与之比对，看是否满足3-sigma理论。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;关于 Moving Average&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;给定一个timeseries和subset长度（比如N天），则datapoint i 的N天 moving average = i之前N天（包括i）的平均值。不停地移动这个长度为N的“窗口”并计算平均值，就得到了一条moving average曲线。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Moving average常用来消除数据短期内的噪音，显示长期趋势；或者根据已有数据预测未来数据。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;Simple Moving Average&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这是最简单的moving average，为“窗口”内datapoints的算数平均值（每个datapoint的weight一样）：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;SMA(i) = [p(i) + p(i-1) + … + p(i-n+1) ]/ n&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;当计算i+1处的SMA时，一个新的值加入，“窗口”左端的值丢弃，因此可得到递推式：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;SMA(i) = SMA(i-1) + p(i)/n – p(i-n+1)/n&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;实现起来也很容易，只要记录上次SMA和将要丢弃的datapoint即可(最开始的几个是没有SMA的)。Pandas中可用 pandas.stats.moments.rolling_mean 计算SMA。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;SMA由于过去的数据和现在的数据权重是一样的，因此它相对真实数据的走向存在延迟，不太适合预测，更适合观察长期趋势。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h4 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;&quot;&gt;Exponential moving average&lt;/h4&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;也称 Exponential-weighted moving average，它和SMA主要有两处不同：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;计算SMA仅“窗口”内的n个datapoint参与计算，而EWMA则是之前所有point； &lt;br/&gt;
EWMA计算average时每个datapoint的权重是不一样的，最近的datapoint拥有越高的权重，随时间呈指数递减。 &lt;br/&gt;
EWMA的递推公式是：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;EWMA&lt;span style=&quot;color: #75715e;&quot;&gt;(1)&lt;/span&gt; = p&lt;span style=&quot;color: #75715e;&quot;&gt;(1)&lt;/span&gt;  &lt;span style=&quot;color: #75715e;&quot;&gt;// 有时也会取前若干值的平均值。α越小时EWMA(1)的取值越重要。&lt;/span&gt;
EWMA&lt;span style=&quot;color: #75715e;&quot;&gt;(i)&lt;/span&gt; = α * p&lt;span style=&quot;color: #75715e;&quot;&gt;(i)&lt;/span&gt; + &lt;span style=&quot;color: #75715e;&quot;&gt;(1-α)&lt;/span&gt; * EWMA&lt;span style=&quot;color: #75715e;&quot;&gt;(i – 1)&lt;/span&gt; &lt;span style=&quot;color: #75715e;&quot;&gt;// α是一个0-1间的小数，称为smoothing factor.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;可以看到比SMA更容易实现，只要维护上次EWMA即可。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;EWMA 的本质其实是，越老的数据在预测时占的比例越低。扩展以上公式可以看到，从i往前的datapoint，权重依次为α, α(1-α), α(1-α)^2….., α(1-α)^n，呈指数递减，权重的和的极限等于1。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;smoothing factor决定了EWMA的 &lt;strong style=&quot;font-weight: bold;&quot;&gt;时效性&lt;/strong&gt; 和 &lt;strong style=&quot;font-weight: bold;&quot;&gt;稳定性&lt;/strong&gt;。α越大时效性越好，越能反映出最近数据状态；α越小越平滑，越能吸收瞬时波动，反映出长期趋势。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;EWMA由于其时效性被广泛应用在“根据已有时间序列预测未来数据”的场景中，（在计算机领域）比较典型的应用是在TCP中估计RTT，即从已有的RTT数据计算未来RTT，以确定超时时间。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;虽然EWMA中参与计算的是全部datapoint，但它也有类似SMA “N天EWMA”的概念，此时α由N决定：α = 2/(N+1)，关于这个公式的由来参见&lt;a href=&quot;http://www.mcoscillator.com/learning_center/kb/market_data/exponential_versus_simple_moving_averages/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;回到Skyline，这里并不是用EWMA来预测未来datapoint，而是类似之前的算法求出整体序列的mean和stdDev，只不过计算时加入了时间的权重（EWMA），越近的数据对结果影响越大，即判断的参照物是最近某段时间而非全序列; 再用last datapoint与之比较。因此它的优势在于:&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;可以检测到一个异常较短时间后发生的另一个(不太高的突变型)异常，其他算法很有可能会忽略，因为第一个异常把整体的平均水平和标准差都拉高了&lt;/li&gt;
&lt;li&gt;比其他算法更快对异常作出反应，因为它更多的是参考突变之前的点（低水平），而非总体水平（有可能被某个异常或者出现较多次的较高的统计数据拉高）&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;而劣势则是&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;对渐进型而非突发型的异常检测能力较弱&lt;/li&gt;
&lt;li&gt;异常持续一段时间后可能被判定为正常&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;mean_subtraction_cumulation&lt;/h3&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;mean_subtraction_cumulation&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the value of the next datapoint in the
    series is farther than a standard deviation out in cumulative terms
    after subtracting the mean from each data point.
    &quot;&quot;&quot;&lt;/span&gt;

    series = pandas.Series([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;else&lt;/span&gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    series = series - series[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;:len(series) - &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;].mean()
    stdDev = series[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;:len(series) - &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;].std()
    expAverage = pandas.stats.moments.ewma(series, com=&lt;span style=&quot;color: #ae81ff;&quot;&gt;15&lt;/span&gt;)

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; abs(series.iget(-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;)) &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt; * stdDev&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;算法如下：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;排除全序列（暂称为all）最后一个值（last datapoint），求剩余序列（暂称为rest，0..length-2）的mean；&lt;/li&gt;
&lt;li&gt;rest序列中每个元素减去rest的mean，再求standard deviation；&lt;/li&gt;
&lt;li&gt;求last datapoint到rest mean的距离，即 abs(last datapoint – rest mean)；&lt;/li&gt;
&lt;li&gt;判断上述距离是否超过rest序列std. dev.的3倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;简单地说，就是用最后一个datapoint和剩余序列比较，比较的过程依然遵循3-sigma。这个算法有2个地方很可疑：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;求剩余序列的std. dev.时先减去mean再求，这一步是多余的，对结果没影响；&lt;/li&gt;
&lt;li&gt;虽然用tail_avg已经很不科学了，这个算法更进一步，只判断最后一个datapoint是否异常，这要求在两次analysis间隔中最多只有一个datapoint被加入，否则就会丢失数据。关于这个问题的讨论，见&lt;a href=&quot;http://jiroujuan.wordpress.com/2013/10/08/skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;最末。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;和stddev_from_average相比，该算法对于 “毛刺” 判断为异常的概率远大于后者。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;least_squares&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;least_squares&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the average of the last three datapoints
    on a projected least squares model is greater than three sigma.
    &quot;&quot;&quot;&lt;/span&gt;

    x = np.array([t[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; t &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    y = np.array([t[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; t &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    A = np.vstack([x, np.ones(len(x))]).T
    results = np.linalg.lstsq(A, y)
    residual = results[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;]
    m, c = np.linalg.lstsq(A, y)[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;]
    errors = []
    &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; i, value &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; enumerate(y):
        projected = m * x[i] + c
        error = value - projected
        errors.append(error)

    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; len(errors) &amp;lt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;:
        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;False&lt;/span&gt;

    std_dev = scipy.std(errors)
    t = (errors[-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] + errors[-&lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt;] + errors[-&lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;]) / &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; abs(t) &amp;gt; std_dev * &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;and&lt;/span&gt; round(std_dev) != &lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;and&lt;/span&gt; round(t) != &lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;用最小二乘法得到一条拟合现有datapoint value的直线；&lt;/li&gt;
&lt;li&gt;用实际value和拟合value的差值组成一个新的序列error；&lt;/li&gt;
&lt;li&gt;求该序列的stdDev，判断序列error的tail_avg是否&amp;gt;3倍的stdDev&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因为最小二乘法的关系，该算法对直线形的metrics比较适用。该算法也有一个问题，在最后判定的时候，不是用tail_avg到error序列的mean的距离，而是直接使用tail_avg的值，这无形中缩小了异常判定范围，也不符合3-sigma。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;小结&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;可以看到上述算法都是类似的思路：用最近的若干datapoint做样本，和一个总体序列进行比对，不同的只是比对的对象：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;stddev_from_average&lt;/strong&gt; &lt;br/&gt;
tail_avg  ———  整个序列&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;first_hour_average&lt;/strong&gt; &lt;br/&gt;
tail_avg  ———-  FULL_DURATION开始的一个小时&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;stddev_from_moving_average&lt;/strong&gt; &lt;br/&gt;
last datapoint ———–  整个序列的EW mean和EW std dev&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;mean_subtraction_cumulation&lt;/strong&gt; &lt;br/&gt;
last datapoint ———  剩余序列&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;least_squares&lt;/strong&gt; &lt;br/&gt;
last datapoint ——– 真实数据和拟合直线间的差值序列&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;grubbs&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;grubbs&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the Z score is greater than the Grubb&#39;s score.
    &quot;&quot;&quot;&lt;/span&gt;

    series = scipy.array([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    stdDev = scipy.std(series)
    mean = np.mean(series)
    tail_average = tail_avg(timeseries)
    z_score = (tail_average - mean) / stdDev
    len_series = len(series)
    threshold = scipy.stats.t.isf(&lt;span style=&quot;color: #ae81ff;&quot;&gt;.05&lt;/span&gt; / (&lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt; * len_series) , len_series - &lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt;)
    threshold_squared = threshold * threshold
    grubbs_score = ((len_series - &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;) / np.sqrt(len_series)) * np.sqrt(threshold_squared / (len_series - &lt;span style=&quot;color: #ae81ff;&quot;&gt;2&lt;/span&gt; + threshold_squared))

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; z_score &amp;gt; grubbs_score
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Grubbs测试是一种从样本中找出outlier的方法，所谓outlier，是指样本中偏离平均值过远的数据，他们有可能是极端情况下的正常数据，也有可能是测量过程中的错误数据。使用Grubbs测试需要总体是正态分布的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;Grubbs测试步骤如下：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;样本从小到大排序；&lt;/li&gt;
&lt;li&gt;求样本的mean和std.dev.；&lt;/li&gt;
&lt;li&gt;计算min/max与mean的差距，更大的那个为可疑值；&lt;/li&gt;
&lt;li&gt;求可疑值的z-score (standard score)，如果大于Grubbs临界值，那么就是outlier；&lt;/li&gt;
&lt;li&gt;Grubbs临界值可以查表得到，它由两个值决定：检出水平α（越严格越小），样本数量n&lt;/li&gt;
&lt;li&gt;排除outlier，对剩余序列循环做 1-5 步骤。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;由于这里需要的是异常判定，只需要判断tail_avg是否outlier即可。代码中还有求Grubbs临界值的过程，看不懂。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Z-score (standard score)&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;标准分，一个个体到集合mean的偏离，以标准差为单位，表达个体距mean相对“平均偏离水平（std dev表达）”的偏离程度，常用来比对来自不同集合的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;histogram_bins&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;histogram_bins&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the average of the last three datapoints falls
    into a histogram bin with less than 20 other datapoints (you&#39;ll need to tweak
    that number depending on your data)

    Returns: the size of the bin which contains the tail_avg. Smaller bin size
    means more anomalous.
    &quot;&quot;&quot;&lt;/span&gt;

    series = scipy.array([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    t = tail_avg(timeseries)
    h = np.histogram(series, bins=&lt;span style=&quot;color: #ae81ff;&quot;&gt;15&lt;/span&gt;)
    bins = h[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;]
    &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; index, bin_size &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; enumerate(h[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;]):
        &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; bin_size &amp;lt;= &lt;span style=&quot;color: #ae81ff;&quot;&gt;20&lt;/span&gt;:
            &lt;span style=&quot;color: #75715e;&quot;&gt;# Is it in the first bin?&lt;/span&gt;
            &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; index == &lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;:
                &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; t &amp;lt;= bins[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;]:
                    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;True&lt;/span&gt;
            &lt;span style=&quot;color: #75715e;&quot;&gt;# Is it in the current bin?&lt;/span&gt;
            &lt;span style=&quot;color: #f92672;&quot;&gt;elif&lt;/span&gt; t &amp;gt;= bins[index] &lt;span style=&quot;color: #f92672;&quot;&gt;and&lt;/span&gt; t &amp;lt; bins[index + &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;]:
                    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;True&lt;/span&gt;

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法和以上都不同，它首先将timeseries划分成15个宽度相等的直方，然后判断tail_avg所在直方内的元素是否&amp;lt;=20，如果是，则异常。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;直方的个数和元素个数判定需要根据自己的metrics调整，不然在数据量小的时候很容易就异常了。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;ks_test&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;ks_test&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if 2 sample Kolmogorov-Smirnov test indicates
    that data distribution for last 10 minutes is different from last hour.
    It produces false positives on non-stationary series so Augmented
    Dickey-Fuller test applied to check for stationarity.
    &quot;&quot;&quot;&lt;/span&gt;

    hour_ago = time() - &lt;span style=&quot;color: #ae81ff;&quot;&gt;3600&lt;/span&gt;
    ten_minutes_ago = time() - &lt;span style=&quot;color: #ae81ff;&quot;&gt;600&lt;/span&gt;
    reference = scipy.array([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;] &amp;gt;= hour_ago &lt;span style=&quot;color: #f92672;&quot;&gt;and&lt;/span&gt; x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;] &amp;lt; ten_minutes_ago])
    probe = scipy.array([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;] &amp;gt;= ten_minutes_ago])

    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; reference.size &amp;lt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;20&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;or&lt;/span&gt; probe.size &amp;lt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;20&lt;/span&gt;:
        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;False&lt;/span&gt;

    ks_d,ks_p_value = scipy.stats.ks_2samp(reference, probe)

    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; ks_p_value &amp;lt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;0.05&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;and&lt;/span&gt; ks_d &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;0.5&lt;/span&gt;:
        adf = sm.tsa.stattools.adfuller(reference, &lt;span style=&quot;color: #ae81ff;&quot;&gt;10&lt;/span&gt;)
        &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;  adf[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &amp;lt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;0.05&lt;/span&gt;:
            &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;True&lt;/span&gt;

    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这个算法比较高深，它将timeseries分成两段：最近10min（probe），1 hour前 -&amp;gt; 10 min前这50分钟内（reference），两个样本通过Kolmogorov-Smirnov测试后判断差异是否较大。如果相差较大，则对refercence这段样本进行 Augmented Dickey-Fuller 检验（ADF检验），查看其平稳性，如果是平稳的，说明存在从平稳状态（50分钟）到另一个差异较大状态（10分钟）的突变，序列认为是异常的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;关于这两个检验过于学术了，以上只是我粗浅的理解。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;Kolmogorov-Smirnov test&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;KS-test有两个典型应用：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;判断某个样本是否满足某个已知的理论分布，如正态/指数/均匀/泊松分布； &lt;br/&gt;
  判断两个样本背后的总体是否可能有相同的分布，or 两个样本间是否可能来自同一总体， or 两个样本是否有显著差异。 &lt;br/&gt;
  检验返回两个值：D，p-value，不太明白他们的具体含义，Skyline里当 p-value &amp;lt; 0.05 &amp;amp;&amp;amp; D &amp;gt; 0.5 时，认为差异显著。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;Augmented Dickey-Fuller test (ADF test)&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;用于检测时间序列的平稳性，当返回的p-value小于给定的显著性水平时，序列认为是平稳的，Skyline取的临界值是0.05。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;median_absolute_deviation&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;def&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;median_absolute_deviation&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(timeseries)&lt;/span&gt;:&lt;/span&gt;
    &lt;span style=&quot;color: #e6db74;&quot;&gt;&quot;&quot;&quot;
    A timeseries is anomalous if the deviation of its latest datapoint with
    respect to the median is X times larger than the median of deviations.
    &quot;&quot;&quot;&lt;/span&gt;

    series = pandas.Series([x[&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;] &lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; x &lt;span style=&quot;color: #f92672;&quot;&gt;in&lt;/span&gt; timeseries])
    median = series.median()
    demedianed = np.abs(series - median)
    median_deviation = demedianed.median()

    &lt;span style=&quot;color: #75715e;&quot;&gt;# The test statistic is infinite when the median is zero,&lt;/span&gt;
    &lt;span style=&quot;color: #75715e;&quot;&gt;# so it becomes super sensitive. We play it safe and skip when this happens.&lt;/span&gt;
    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; median_deviation == &lt;span style=&quot;color: #ae81ff;&quot;&gt;0&lt;/span&gt;:
        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;False&lt;/span&gt;

    test_statistic = demedianed.iget(-&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;) / median_deviation

    &lt;span style=&quot;color: #75715e;&quot;&gt;# Completely arbitary...triggers if the median deviation is&lt;/span&gt;
    &lt;span style=&quot;color: #75715e;&quot;&gt;# 6 times bigger than the median&lt;/span&gt;
    &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt; test_statistic &amp;gt; &lt;span style=&quot;color: #ae81ff;&quot;&gt;6&lt;/span&gt;:
        &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; &lt;span style=&quot;color: #f92672;&quot;&gt;True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法不是基于mean/ standard deviation的，而是基于median / median of deviations (MAD)。&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Median&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;大部分情况下我们用mean来表达一个集合的平均水平（average），但是在某些情况下存在少数极大或极小的outlier，拉高或拉低了（skew）整体的mean，造成估计的不准确。此时可以用median（中位数）代替mean描述平均水平。Median的求法很简单，集合排序中间位置即是，如果集合总数为偶数，则取中间二者的平均值。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;Median of deviation（MAD）&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;同mean一样，对于median我们也需要类似standard deviation这样的指标来表达数据的&lt;strong style=&quot;font-weight: bold;&quot;&gt;紧凑/分散程度&lt;/strong&gt;，即偏离average的平均距离，这就是MAD。MAD顾名思义，是deviation的median，而此时的deviation = abs( 个体 – median )，避免了少量outlier对结果的影响，更robust。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;现在算法很好理解了：求出序列的MAD，看最后datapoint与MAD的距离是否 &amp;gt; 6个MAD。同样的，这里用最后一个datapoint判定，依然存在之前提到的问题；其次，6 是个“magic number”，需要根据自己metrics数据特点调整。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该算法的优势在于对异常更加敏感：假设metric突然变很高并保持一段时间，基于标准差的算法可能在异常出现较短时间后即判断为正常，因为少量outlier对标准差的计算是有影响的；而计算MAD时，若异常datapoint较少会直接忽略，因此感知异常的时间会更长。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;但正如Median的局限性，该算法对于由多个cluster组成的数据集，即数据分布在几个差距较大的区间内，效果很差，很容易误判。比如下图：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1409641576810.png&quot; name=&quot;6cf349c1-221b-4238-90bc-3dcf26e03b6e&quot; src=&quot;/assets/img/5feab8dcfcc970bb9a568cccc928fe69.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;该曲线在两个区间内来回震荡，此时median为58，如红线所示。MAD计算则为9，很明显均不能准确描述数据集，最后节点的deviation=55，此时误判了。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;各种Wiki&lt;/li&gt;
&lt;li&gt;各种API文档&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://chenlinux.com/2013/06/19/skyline-algorithms-intro/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;前辈的总结：【Etsy 的 Kale 系统】skyline 的过滤算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.investopedia.com/university/movingaverage/movingaverages1.asp&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Moving Averages: What Are They?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/ccfa573a3968011ca30091d6.html&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Kolmogorov-Smirnov检验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wenku.baidu.com/view/84695b4e852458fb770b56bb.html&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Grubbs检验法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/tianguokaka/article/details/7741812&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Median absolute deviation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Head first statistics》&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>排序总结</title>
      <link>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html</link>
      <pubDate>05 Aug 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/排序总结</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;排序总结&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. 插入&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;直接插入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3.  交换&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. 选择&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. 其他&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;5. 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;strong style=&quot;font-weight: bold;&quot;&gt;基于比较&lt;/strong&gt;&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;插入：直接插入 / 希尔&lt;/li&gt;
&lt;li&gt;交换：冒泡 / 快排&lt;/li&gt;
&lt;li&gt;选择：堆排序&lt;/li&gt;
&lt;li&gt;归并&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;2. 插入&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;直接插入&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;稳定，就地，平均&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;18.375&quot; longdesc=&quot;__SVG__3987120c67ed5a9162aa9841b531c3a9&quot; name=&quot;e7725cde-0677-4af7-8331-0a7e6e6ad1e6&quot; src=&quot;/assets/img/2f448670958a1592e213e882b38ab255&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;39.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，最好情况(初始有序)下 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__1f08ccc9cd7309ba1e756c3d9345ad9f&quot; name=&quot;8663c24e-7590-4e88-a214-30b9afb247e1&quot; src=&quot;/assets/img/b4eda6a069583b5ac4ddff041938993d&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;32.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想：数组被分成两个部分，一个有序一个无序，依次将无序中的元素插入有序部分。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;数据若基本有序，插入排序可以大大减少数据交换次数，提升效率。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;希尔排序&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;非稳定，就地，&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;18.375&quot; longdesc=&quot;__SVG__9256f9feb90e18db29a7d9bed2cd89b0&quot; name=&quot;a93e8bb8-2883-431e-a4de-e854ca268652&quot; src=&quot;/assets/img/4db8c074933f19a989d2310550454d4a&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;39.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; (1 &amp;lt; λ &amp;lt; 2)&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想：先将序列按增量划分为元素个数近似的若干组，使用直接插入排序法对每组进行排序，不断缩小增量并排序，直到增量为1。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;因为增量初始值不容易选择，所以该算法不常用。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;3.  交换&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;冒泡排序&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;稳定，就地，平均 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;18.375&quot; longdesc=&quot;__SVG__3987120c67ed5a9162aa9841b531c3a9&quot; name=&quot;e7725cde-0677-4af7-8331-0a7e6e6ad1e6&quot; src=&quot;/assets/img/2f448670958a1592e213e882b38ab255&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;39.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，最好(初始有序) &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__1f08ccc9cd7309ba1e756c3d9345ad9f&quot; name=&quot;8663c24e-7590-4e88-a214-30b9afb247e1&quot; src=&quot;/assets/img/b4eda6a069583b5ac4ddff041938993d&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;32.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想：数组被分成两个部分，一个有序一个无序，不断将较大元素冒泡到无序子序列首。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;若某趟冒泡未发生交换，说明数组已经有序，可提前结束。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;快速排序&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;不稳定，就地，平均 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__0c0eae8913b6841c2d3724b34d3e2b78&quot; name=&quot;78c2cf25-c230-4247-821d-0d3af715d929&quot; src=&quot;/assets/img/26a15e3cd27d61ce19b7859ecc270549&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;53.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，最差情况(每次 partition 后 pivot 在最前或最后) &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;18.375&quot; longdesc=&quot;__SVG__3987120c67ed5a9162aa9841b531c3a9&quot; name=&quot;e7725cde-0677-4af7-8331-0a7e6e6ad1e6&quot; src=&quot;/assets/img/2f448670958a1592e213e882b38ab255&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;39.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想：每次选定一个 pivot 将数组分割成两个部分，对二者递归应用这个过程。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;3. 选择&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;堆排序&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;不稳定，就地，始终 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__0c0eae8913b6841c2d3724b34d3e2b78&quot; name=&quot;78c2cf25-c230-4247-821d-0d3af715d929&quot; src=&quot;/assets/img/26a15e3cd27d61ce19b7859ecc270549&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;53.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想： 数组建大根堆，不停地 remove 第一个元素放到最后，并重新调整堆。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;4. 其他&lt;/h2&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h3 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;&quot;&gt;归并排序&lt;/h3&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;特点：&lt;strong style=&quot;font-weight: bold;&quot;&gt;稳定，非就地，时间始终是 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__0c0eae8913b6841c2d3724b34d3e2b78&quot; name=&quot;78c2cf25-c230-4247-821d-0d3af715d929&quot; src=&quot;/assets/img/26a15e3cd27d61ce19b7859ecc270549&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;53.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，空间&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__1f08ccc9cd7309ba1e756c3d9345ad9f&quot; name=&quot;8663c24e-7590-4e88-a214-30b9afb247e1&quot; src=&quot;/assets/img/b4eda6a069583b5ac4ddff041938993d&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;32.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;思想：首先，将整个序列（共N个元素）看成N个有序子序列，然后依次合并相邻的两个子序列，这样一直下去，直至变成一个整体有序的序列。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;适用场景：外部排序&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;大部分简单排序(直接插入排序 / 冒泡排序)都是稳定排序； &lt;br/&gt;
大部分高级排序都是不稳定排序，除了 &lt;strong style=&quot;font-weight: bold;&quot;&gt;归并排序&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</link>
      <pubDate>05 Aug 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/快速排序</guid>
      <description>&lt;div style=&quot;line-height: 1.6; font-family: Helvetica Neue, Arial, Hiragino Sans GB, STHeiti, Microsoft YaHei, WenQuanYi Micro Hei, SimSun, Song, sans-serif;&quot;&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;怎么写一个正确的快速排序？&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;sort()&lt;/code&gt;方法很简单：&lt;/p&gt;
&lt;pre style=&quot;overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;&quot;&gt;&lt;span style=&quot;color: #F92672;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #F92672;&quot;&gt;void&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;sort&lt;/span&gt;(&lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt;[] num,&lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; start, &lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; end){
    &lt;span style=&quot;color: #F92672;&quot;&gt;if&lt;/span&gt;(start &amp;gt;= end) &lt;span style=&quot;color: #F92672;&quot;&gt;return&lt;/span&gt;;

    &lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; i = partition(num,start,end);
    sort(num,start, i - &lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;);
    sort(num,i+&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;,end);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;主要的难点在&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;partition()&lt;/code&gt;方法。假定选定第一个元素为 pivot，且一次 partition 后数组分为两部分，左侧&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;&amp;lt;=&lt;/code&gt;pivot，右侧&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;&amp;gt;=&lt;/code&gt;pivot。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;首先考虑一般情况。根据算法，我们需要两个指针 i/j 初始指向数组的两端，i 之前的元素 &amp;lt;= pivot，j 之后的元素 &amp;gt;= pivot。两个指针均向中间移动，直到找到第一个不符合条件的元素。二者均停止时，交换 i/j 指针指向的元素，并重复这个过程。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1407240921581.png&quot; name=&quot;875cdb5c-19e2-4277-a8a1-9a5a1329c143&quot; src=&quot;/assets/img/a704a724a9d9f3ac2923ade3934d0bbe.png&quot; style=&quot;border: 0; max-width: 100%; border-radius: 8px;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;很快可以写出算法的主要框架：&lt;/p&gt;
&lt;pre style=&quot;overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;&quot;&gt;&lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(...){
    &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(a[i] &amp;lt;= pivot) i++;
    &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(a[j] &amp;gt;= pivot) j--;
    swap(a,i,j);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;循环写出来了，自然要考虑什么时候停下来。稍微推演可知，当 i/j 两个指针穷尽了各自的区间时应当停止循环，此时 i和j 是个 &lt;strong style=&quot;font-weight: bold;&quot;&gt;交错的状态&lt;/strong&gt;，i 指向 &amp;gt;= 区域的第一个元素，j 指向 &amp;lt;= 区域的最后一个元素，如下所示：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1407245030987.png&quot; name=&quot;f99cadc0-a6e4-42b0-8478-6b206ae293fb&quot; src=&quot;/assets/img/0568de1c5403812afa20616e65f4ca20.png&quot; style=&quot;border: 0; max-width: 100%; border-radius: 8px;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;这时不能再交换 i/j 上的元素，而应将 pivot 移动到 &lt;strong style=&quot;font-weight: bold;&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;j&lt;/code&gt;&lt;/strong&gt; 处，并 return 该位置；至此一次 partition 就完成了。把这些想法加上，代码如下：&lt;/p&gt;
&lt;pre style=&quot;overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;&quot;&gt;&lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(i&amp;lt;j){
    &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(a[i] &amp;lt;= pivot) i++;   &lt;span style=&quot;color: #75715e;&quot;&gt;// 1&lt;/span&gt;
    &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(a[j] &amp;gt;= pivot) j--;    &lt;span style=&quot;color: #75715e;&quot;&gt;// 2&lt;/span&gt;
    &lt;span style=&quot;color: #F92672;&quot;&gt;if&lt;/span&gt;(i&amp;lt;j)
        swap(a,i,j);
}
swap(a,start,j);

&lt;span style=&quot;color: #F92672;&quot;&gt;return&lt;/span&gt; j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;上述 1/2 处的循环看起来很有数组越界的危险，而事实也是如此。用几个 edge case 考察下，假设所有元素都 &amp;lt;= pivot，很明显循环1会越界，因此这里需要加上对边界的判断；当数组除 pivot 之外的元素都 &amp;gt; pivot 时，循环2也是一样的情况。这两个越界问题都可以通过 &lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;i&amp;lt;=j&lt;/code&gt; 这个判断解决。注意要加上等号，否则 i/j 不会交错，逻辑错误。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;用 edge case 对其他逻辑测试下都没问题，因此加上数组越界的防范就够了；最后&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 90%; padding: 0 4px; color: #c7254e; background-color: #f9f2f4; white-space: nowrap; border-radius: 8px; margin: 0 4px;&quot;&gt;partition()&lt;/code&gt;的完整代码如下：&lt;/p&gt;
&lt;pre style=&quot;overflow: initial; font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: 14px; display: block; padding: 0; margin: 0 0 10px; line-height: 1.6; word-break: break-all; word-wrap: break-word; color: #333333; background-color: #f5f5f5; border: none; border-radius: 0; white-space: pre-wrap; background: transparent;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Menlo, Monaco, Consolas, Courier New, monospace; font-size: inherit; padding: 1em; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 8px; display: block; background: #23241f; margin: 0 4px;&quot;&gt;&lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; partition(&lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt;[] a, &lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; start, &lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; end){
    &lt;span style=&quot;color: #F92672;&quot;&gt;int&lt;/span&gt; i = start, j = end, pivot = a[start];

    &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(i &amp;lt; j){
        &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(i &amp;lt;= j &amp;amp;&amp;amp; a[i] &amp;lt;= pivot) i++;   &lt;span style=&quot;color: #75715e;&quot;&gt;// 加上越界判断&lt;/span&gt;
        &lt;span style=&quot;color: #F92672;&quot;&gt;while&lt;/span&gt;(i &amp;lt;= j &amp;amp;&amp;amp; a[j] &amp;gt;= pivot) j--;   &lt;span style=&quot;color: #75715e;&quot;&gt;// 加上越界判断&lt;/span&gt;
        &lt;span style=&quot;color: #F92672;&quot;&gt;if&lt;/span&gt;(i &amp;lt; j){
            swap(a,i,j);
        }
    }
    swap(a,start,j);

    &lt;span style=&quot;color: #F92672;&quot;&gt;return&lt;/span&gt; j;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;从这个过程总结一下平常写（算法）代码的思路：&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 10px; line-height: 1.6;&quot;&gt;
&lt;li style=&quot;line-height: 1.6;&quot;&gt;根据抽象流程定下算法框架；&lt;/li&gt;
&lt;li style=&quot;line-height: 1.6;&quot;&gt;考虑循环（或递归）何时结束，结束时的处理方式；&lt;/li&gt;
&lt;li style=&quot;line-height: 1.6;&quot;&gt;用 edge case 测试代码，修正如数组越界 / 空指针异常等错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p style=&quot;margin: 0 0 10px; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word;&quot;&gt;总体而言是个从抽象到细节的过程。&lt;/p&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>几个常见的概率问题</title>
      <link>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html</link>
      <pubDate>05 Aug 2014</pubDate>
      <author>克鲁斯卡尔</author>
      <guid>http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/08/05/几个常见的概率问题</guid>
      <description>&lt;div style=&quot;line-height: 1.5; color: #2c3f51;&quot;&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;
&lt;/div&gt;&lt;div&gt;

&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;div&gt;&lt;div&gt;&lt;div&gt;
&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;几个常见的概率问题&lt;/a&gt;&lt;ul style=&quot;margin-top: 0; margin-bottom: 15px; list-style-type: none;&quot;&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;1. 洗牌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;2. 随机数生成器的转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;3. 蓄水池抽样&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot;&gt;4. 参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;今天研究了下几个简单的概率问题，在这里记录下。&lt;/p&gt;&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;1. 洗牌&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;问题很简单，有 n 个元素，设计一个能保证随机性的洗牌算法。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;直觉想到的算法是：&lt;/p&gt;
&lt;blockquote style=&quot;padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;&quot;&gt;
&lt;p style=&quot;margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;&quot;&gt;用一个数组作为新牌堆，不停地从原数组剩下的元素中随机挑一个放入新牌堆，直到原牌堆耗尽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;我们来验证一下它的随机性。考虑一个元素，洗牌后它在第一个位置（即第一次抽牌就选中它）的概率是:&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;35&quot; longdesc=&quot;__SVG__49861a1362f5d29a2d04fee3fa4762e8&quot; name=&quot;0cc0ca94-22d0-4dd1-aeb4-006a7a5a05f4&quot; src=&quot;/assets/img/3f17656b5cb9a1ea355e0e7d4b423a8b&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;14.875&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;在第二个位置的概率是：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;105&quot; longdesc=&quot;__SVG__9ff3203a664f125fc3346c37e86ffdb8&quot; name=&quot;55b5a2e1-9b0c-4672-a73d-23afa1a562ba&quot; src=&quot;/assets/img/475c80801a60fc5e09d937b6f1afe68e&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;276.5&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;依次类推，可知该元素将被等概率地分配到任意位置，符合要求。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;按该思路实现洗牌算法时有两个问题。首先，新牌堆显然需要 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__1f08ccc9cd7309ba1e756c3d9345ad9f&quot; name=&quot;731ea3a8-2f6c-4166-9cce-0afdbe522373&quot; src=&quot;/assets/img/18802eaff9aa0dd3d392e4efa69dde7c&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;32.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的空间；其次，元素从旧数组移入新牌堆后势必会留下空洞，在后续抽牌时要跳过这些空洞位置。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;但实际上，新牌堆和旧牌堆元素之和始终为 n，因此整个洗牌过程可以就地完成。&lt;strong style=&quot;font-weight: bold;&quot;&gt;我们可以从前向后遍历，对元素 i，前 i-1 个位置构成新牌堆，i 及其后续元素属于旧牌堆。从旧牌堆中随机抽一个元素，与 i 处元素交换，即完成了一次抽牌动作&lt;/strong&gt;：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;img alt=&quot;Alt text&quot; class=&quot;en-media&quot; longdesc=&quot;./1407165876987.png&quot; name=&quot;7181a84e-10b9-436c-a70f-45240438418a&quot; src=&quot;/assets/img/1a87c760b2ed0738a84555935ac5928d.png&quot; style=&quot;border: 0; vertical-align: middle; max-width: 100%;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;这个算法还有个名字，&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Fisher–Yates shuffle&lt;/code&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;代码：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;function&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;shuffle&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;(array)&lt;/span&gt; &lt;/span&gt;{
  &lt;span style=&quot;color: #f92672;&quot;&gt;var&lt;/span&gt; m = &lt;span style=&quot;color: #f92672;&quot;&gt;array&lt;/span&gt;.length, i;

  &lt;span style=&quot;color: #75715e;&quot;&gt;// While there remain elements to shuffle…&lt;/span&gt;
  &lt;span style=&quot;color: #75715e;&quot;&gt;// 为了方便这里是从后往前遍历的&lt;/span&gt;
  &lt;span style=&quot;color: #f92672;&quot;&gt;while&lt;/span&gt; (m) {

    &lt;span style=&quot;color: #75715e;&quot;&gt;// Pick a remaining element…&lt;/span&gt;
    i = Math.floor(Math.random() * m--);

    &lt;span style=&quot;color: #75715e;&quot;&gt;// And swap it with the current element.&lt;/span&gt;
    &lt;span style=&quot;color: #f92672;&quot;&gt;var&lt;/span&gt; t = &lt;span style=&quot;color: #f92672;&quot;&gt;array&lt;/span&gt;[m];
    &lt;span style=&quot;color: #f92672;&quot;&gt;array&lt;/span&gt;[m] = &lt;span style=&quot;color: #f92672;&quot;&gt;array&lt;/span&gt;[i];
    &lt;span style=&quot;color: #f92672;&quot;&gt;array&lt;/span&gt;[i] = t;
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;2. 随机数生成器的转换&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;听名字有点绕，其实就是给你一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand5()&lt;/code&gt;，表示随机生成 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__e436fc771d3f29fa0eb7504061b620c4&quot; name=&quot;b02ef188-8fe1-4fd8-969d-b4f1a27259e3&quot; src=&quot;/assets/img/8d5b6842f6dda1004a7f76cb1a08cfa3&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;35&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 之间的数字，让你实现一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand3()&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;int&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;Rand3&lt;/span&gt;&lt;span style=&quot;color: #f8f8f2;&quot;&gt;()&lt;/span&gt;  
&lt;/span&gt;{  
    &lt;span style=&quot;color: #f92672;&quot;&gt;int&lt;/span&gt; x = &lt;span style=&quot;color: #ae81ff;&quot;&gt;5&lt;/span&gt;;  
    &lt;span style=&quot;color: #f92672;&quot;&gt;while&lt;/span&gt;(x &amp;gt;= &lt;span style=&quot;color: #ae81ff;&quot;&gt;3&lt;/span&gt;) 
        x = Rand5();  
    &lt;span style=&quot;color: #f92672;&quot;&gt;return&lt;/span&gt; x;  
}  &lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;逻辑很简单，用&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand5()&lt;/code&gt;不停地产生随机数，直到某个数字落在了 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__fe309a23016755cc5ed88917878b89e5&quot; name=&quot;5db14838-9a04-4dc0-8081-37043d87d364&quot; src=&quot;/assets/img/2f0a5b4bcc0f342409b531cbcb0a9f5f&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;35&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 内。最终只会生成 0/1/2 三个数字，看起来似乎每个数字都是等概率的。下面来证明这个结论：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;以输出0为例，看看概率是多少。第一次 Rand5 返回 0 的概率是1/5，如果返回3或4（2/5 的概率），则需要调用第二次，同样的，也是1/5的概率得到 0，2/5 的概率得到3或4导致循环继续执行下去，如此反复。因此输出 0 的概率为：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;232.75&quot; longdesc=&quot;__SVG__5c819d4e1f08a54a7466b5dbef22b276&quot; name=&quot;03a6ca71-14e3-4420-b77b-c9ce2cc95f89&quot; src=&quot;/assets/img/0beca4bfb94ae7df66d05986a90c919f&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;347.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;显然这种方法是正确的。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;换一下题目，给一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand(3)&lt;/code&gt;，怎么生成一个&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand(5)&lt;/code&gt;呢？由于 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__230b150b8ff4d4a5ba4929aac2121d0b&quot; name=&quot;89771610-6621-4143-91c1-23ebeee87ff1&quot; src=&quot;/assets/img/1310a224d6a91503152b0a32587e51e8&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;158.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 可以构造出&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand(9)&lt;/code&gt;，对它再应用上述算法即可。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;解释下 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__230b150b8ff4d4a5ba4929aac2121d0b&quot; name=&quot;89771610-6621-4143-91c1-23ebeee87ff1&quot; src=&quot;/assets/img/1310a224d6a91503152b0a32587e51e8&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;158.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为什么可以得到&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;Rand(9)&lt;/code&gt;。&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__825626ce6bb0c94b65351efbb1357981&quot; name=&quot;1c1a7f52-b4fd-47f9-8d84-95d88e850ab0&quot; src=&quot;/assets/img/0b10345541f4ba83287023ef0a94cedb&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;83.125&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 得到一个随机数集合&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;0,3,6&lt;/code&gt;，&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__7bfd91c8c1dd640ac5432fbc6ec23b3c&quot; name=&quot;8a47089a-a08b-4f12-899b-1f2ab70cd46a&quot; src=&quot;/assets/img/4acd4692dcc6e04b8c438e5a42be0071&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;56&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 得到&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;&quot;&gt;0,1,2&lt;/code&gt;，二者相加的结果刚好均匀地分布在 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;14.875&quot; longdesc=&quot;__SVG__e17cbf8e7f67a536eb6e05e56fba7504&quot; name=&quot;ed211632-e20c-4d52-a261-74098970aea0&quot; src=&quot;/assets/img/b1cf8ee045f54d9f9c44448362a5cab0&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;35&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 区间内。推广这个结论可得，&lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;15.75&quot; longdesc=&quot;__SVG__854c312b08598f30777baa4e8fe990d2&quot; name=&quot;5700aeb1-932d-4c8c-a765-f8cdbe0bab8e&quot; src=&quot;/assets/img/c2cc10c2730ccc0fb323b9e868ac87da&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;176.75&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 可以得到 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;18.375&quot; longdesc=&quot;__SVG__0a8c394c2270f3d2f72293343eecc339&quot; name=&quot;8b132115-bf89-462b-8613-262a9767841a&quot; src=&quot;/assets/img/4560cdb5e85b30a0cfe28c4f7a9e01c5&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;49.875&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 区间内的随机数生成器。&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;3. 蓄水池抽样&lt;/h2&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;蓄水池抽样是要解决这样一个问题：给定一个很大的集合，集合总数 n 不能确定，只能遍历一遍，要求从中随机选取 k 个元素。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;蓄水池算法的原理是：维护一个大小为 k 的蓄水池，用集合的前 k 个元素初始化之；对后续每个元素 i，都以 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;22.75&quot; longdesc=&quot;__SVG__58293d9bb655e706895b6320fb510e16&quot; name=&quot;e8c433ed-516f-4600-a2a0-987ec24ad424&quot; src=&quot;/assets/img/da289e1c201e66cc838e6a9a02476c14&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;11.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的概率替换掉蓄水池中的某个元素。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;代码：&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;
&lt;pre style=&quot;font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;&quot; xml:space=&quot;preserve&quot;&gt;&lt;code style=&quot;font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;&quot;&gt;Init : &lt;span&gt;a&lt;/span&gt; reservoir &lt;span&gt;with&lt;/span&gt; &lt;span&gt;the&lt;/span&gt; size： k  
&lt;span style=&quot;color: #f92672;&quot;&gt;for&lt;/span&gt; i= k+&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt; &lt;span style=&quot;color: #e6db74;&quot;&gt;to&lt;/span&gt; n  
   M=&lt;span style=&quot;color: #e6db74;&quot;&gt;random&lt;/span&gt;(&lt;span style=&quot;color: #ae81ff;&quot;&gt;1&lt;/span&gt;, i);  
   &lt;span style=&quot;color: #f92672;&quot;&gt;if&lt;/span&gt;( M &amp;lt; k)  
        SWAP &lt;span&gt;the&lt;/span&gt; Mth &lt;span style=&quot;color: #e6db74;&quot;&gt;value&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; ith &lt;span style=&quot;color: #e6db74;&quot;&gt;value&lt;/span&gt;  
&lt;span style=&quot;color: #f92672;&quot;&gt;&lt;span style=&quot;color: #66d9ef;&quot;&gt;end&lt;/span&gt; &lt;span style=&quot;color: #a6e22e;&quot;&gt;for&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;下面来证明一下该算法的正确性。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;对某个元素，第一次就选中它的概率是 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;21.875&quot; longdesc=&quot;__SVG__179b80cc86f52ed7205e115c2a3ddc1b&quot; name=&quot;e8308607-1a09-4761-8f35-a857eb82298b&quot; src=&quot;/assets/img/0ea1513cd57dbc7f585b3d6dbe0a5fde&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;12.25&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，第二次才选中它的概率是 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;22.75&quot; longdesc=&quot;__SVG__3ed767005f8cf83b745a833a73774968&quot; name=&quot;ea74d573-f3b0-45a2-b316-c31f2b8cb7ac&quot; src=&quot;/assets/img/fa7c2c689e4729716d097b6f67790cfa&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;128.625&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，第三次第四次也类似，这跟之前的洗牌场景很像。因此，最终该元素被选中的概率就等于 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;21.875&quot; longdesc=&quot;__SVG__b2501e99a0ce9442ccfed26d372bbd24&quot; name=&quot;739ad5e1-6f1e-45b6-9e85-572738de6731&quot; src=&quot;/assets/img/3fd31a581f6f8a25112896b4b4db0bd6&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;12.25&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;当 n == k 时，每个元素出现在蓄水池的概率都是1，即 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;22.75&quot; longdesc=&quot;__SVG__11d2f43ebfc69c2d1cb6e1d0b6f10e08&quot; name=&quot;7e0df589-865d-47c6-a37c-cb9fa6011916&quot; src=&quot;/assets/img/0c96e507b7940337f552d0ea3af6299d&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;11.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;当 n == k+1 时，第一次考察发生在元素 k+1 处，根据算法，它被放入蓄水池的概率为 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;23.625&quot; longdesc=&quot;__SVG__b72f313005ff581330fb54a0ab3c2166&quot; name=&quot;72f6da18-6469-4055-84cf-4b2eddd53c5c&quot; src=&quot;/assets/img/2ad4af9f1eabb23ee42ac3807b772864&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;25.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；对原蓄水池中的任一元素，该次考察后被换出去的概率等于：&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;105.875&quot; longdesc=&quot;__SVG__98e761e6999555665cc7466be80cbbb3&quot; name=&quot;068ac8b3-0065-4d67-bf49-c940daab64d9&quot; src=&quot;/assets/img/a85c57c8be70611b24f70a80575f386a&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;499.625&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;所以，元素依然在蓄水池内的概率为 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;23.625&quot; longdesc=&quot;__SVG__c94baee184698f33b8c47497ef4567db&quot; name=&quot;76604338-e853-4dda-92d2-a79576435797&quot; src=&quot;/assets/img/025327d6f9171ce2d2c76897e38ff021&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;224&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;当 n == k+2 时，根据2，前 k+1 内的元素在第二次考察（即考察第 k+2 个元素）前在蓄水池内的概率为 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;23.625&quot; longdesc=&quot;__SVG__b72f313005ff581330fb54a0ab3c2166&quot; name=&quot;72f6da18-6469-4055-84cf-4b2eddd53c5c&quot; src=&quot;/assets/img/2ad4af9f1eabb23ee42ac3807b772864&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;25.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;同样的，第 k+2 个元素被放入蓄水池的概率为 &lt;span&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;23.625&quot; longdesc=&quot;__SVG__b77f0b654d7f8b3ec33ebf6c32049af9&quot; name=&quot;67e1df3d-33da-4dc6-aafe-4190baee1555&quot; src=&quot;/assets/img/8bb52020c5216b87e52c5efde38969dc&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;25.375&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;对前 k+1 的元素，在第二次考察后在蓄水池要求 1)之前就在蓄水池；2)这次没有被交换出去： &lt;br/&gt;
&lt;/p&gt;&lt;div&gt;&lt;div style=&quot;text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;&quot;&gt;&lt;span style=&quot;font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;&quot;&gt;&lt;span&gt;&lt;img class=&quot;en-media&quot; height=&quot;176.75&quot; longdesc=&quot;__SVG__96df200743c7e2d899a90510b83eacdd&quot; name=&quot;e73d0ba1-39d7-45e4-ad51-87df0cd03393&quot; src=&quot;/assets/img/98099a39d68c6dbf4895a6d91c019aed&quot; style=&quot;margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;&quot; width=&quot;465.5&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;
也符合条件。&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p style=&quot;margin: 0 0 1.1em;&quot;&gt;推广上述过程即可得证。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;div&gt;
&lt;h2 style=&quot;font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;&quot;&gt;4. 参考&lt;/h2&gt;
&lt;ol style=&quot;margin-top: 0; margin-bottom: 1.1em;&quot;&gt;&lt;li&gt;&lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;Fisher–Yates Shuffle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gocalf.com/blog/build-rand3-from-rand5.html&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;利用等概率Rand5产生等概率Rand3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/hackbuteer1/article/details/7971328&quot; style=&quot;background: transparent; color: #1980e6; text-decoration: none;&quot; target=&quot;_blank&quot;&gt;海量数据随机抽样问题（蓄水池问题）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>